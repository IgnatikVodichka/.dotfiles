import * as embedded from '@volar/language-core';
import * as embeddedLS from '@volar/language-service';
import * as path from 'typesafe-path';
import type * as ts from 'typescript/lib/tsserverlibrary';
import { URI } from 'vscode-uri';
import { WorkspaceContext } from './workspace';
import { ServerConfig } from './utils/serverConfig';
export interface ProjectContext {
    workspace: WorkspaceContext;
    rootUri: URI;
    tsConfig: path.PosixPath | ts.CompilerOptions;
    documentRegistry: ts.DocumentRegistry;
    serverConfig: ServerConfig | undefined;
}
export type Project = ReturnType<typeof createProject>;
export declare function createProject(context: ProjectContext): Promise<{
    tsConfig: ts.CompilerOptions | path.PosixPath;
    scripts: {
        clear: () => void;
        values: () => IterableIterator<{
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        }>;
        uriDelete: (_uri: string) => boolean;
        uriGet: (_uri: string) => {
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        } | undefined;
        uriHas: (_uri: string) => boolean;
        uriSet: (_uri: string, item: {
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        }) => void;
        pathDelete: (path: string) => boolean;
        pathGet: (path: string) => {
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        } | undefined;
        pathHas: (path: string) => {
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        } | undefined;
        pathSet: (path: string, item: {
            version: number;
            fileName: string;
            snapshot: ts.IScriptSnapshot | undefined;
            snapshotVersion: number | undefined;
        }) => void;
    };
    languageServiceHost: embedded.LanguageServiceHost;
    getLanguageService: () => {
        doValidation: (uri: string, token?: embeddedLS.CancellationToken | undefined, response?: ((result: embeddedLS.Diagnostic[]) => void) | undefined) => Promise<embeddedLS.Diagnostic[]>;
        findReferences: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.Location[] | undefined>;
        findFileReferences: (uri: string) => embeddedLS.NullableResult<embeddedLS.Location[]>;
        findDefinition: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        findTypeDefinition: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        findImplementations: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        prepareRename: (uri: string, position: embeddedLS.Position) => Promise<NonNullable<embeddedLS.Range | embeddedLS.ResponseError<void> | null | undefined> | undefined>;
        doRename: (uri: string, position: embeddedLS.Position, newName: string) => Promise<embeddedLS.WorkspaceEdit | undefined>;
        getEditsForFileRename: (oldUri: string, newUri: string) => Promise<embeddedLS.WorkspaceEdit | undefined>;
        getSemanticTokens: (uri: string, range: embeddedLS.Range | undefined, legend: embeddedLS.SemanticTokensLegend, cancelToken: embeddedLS.CancellationToken, reportProgress?: ((tokens: embeddedLS.SemanticToken[]) => void) | undefined) => Promise<embeddedLS.SemanticToken[] | undefined> | undefined;
        doHover: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.Hover | undefined>;
        doComplete: (uri: string, position: embeddedLS.Position, completionContext?: embeddedLS.CompletionContext | undefined) => Promise<embeddedLS.CompletionList>;
        doCodeActions: (uri: string, range: embeddedLS.Range, codeActionContext: embeddedLS.CodeActionContext) => Promise<embeddedLS.CodeAction[] | undefined>;
        doCodeActionResolve: (item: embeddedLS.CodeAction) => Promise<embeddedLS.CodeAction>;
        doCompletionResolve: (item: embeddedLS.CompletionItem) => Promise<embeddedLS.CompletionItem>;
        getSignatureHelp: (uri: string, position: embeddedLS.Position, signatureHelpContext?: embeddedLS.SignatureHelpContext | undefined) => Promise<embeddedLS.SignatureHelp | undefined>;
        doCodeLens: (uri: string) => Promise<embeddedLS.CodeLens[]>;
        doCodeLensResolve: (item: embeddedLS.CodeLens) => Promise<embeddedLS.CodeLens>;
        findDocumentHighlights: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.DocumentHighlight[] | undefined>;
        findDocumentLinks: (uri: string) => Promise<embeddedLS.DocumentLink[]>;
        findWorkspaceSymbols: (query: string) => Promise<embeddedLS.SymbolInformation[]>;
        doAutoInsert: (uri: string, position: embeddedLS.Position, autoInsertContext: {
            lastChange: {
                range: embeddedLS.Range;
                rangeOffset: number;
                rangeLength: number;
                text: string;
            };
        }) => Promise<NonNullable<string | embeddedLS.TextEdit | null | undefined> | undefined>;
        doExecuteCommand: (command: string, args: embeddedLS.ExecutePluginCommandArgs, executeCommandContext: embeddedLS.ExecuteCommandContext) => Promise<void>;
        getInlayHints: (uri: string, range: embeddedLS.Range) => Promise<embeddedLS.InlayHint[] | undefined>;
        callHierarchy: {
            doPrepare(uri: string, position: embeddedLS.Position): Promise<embeddedLS.CallHierarchyItem[] | undefined>;
            getIncomingCalls(item: embeddedLS.CallHierarchyItem): Promise<embeddedLS.CallHierarchyIncomingCall[]>;
            getOutgoingCalls(item: embeddedLS.CallHierarchyItem): Promise<embeddedLS.CallHierarchyOutgoingCall[]>;
        };
        dispose: () => void;
        context: embeddedLS.LanguageServiceRuntimeContext;
    };
    getLanguageServiceDontCreate: () => {
        doValidation: (uri: string, token?: embeddedLS.CancellationToken | undefined, response?: ((result: embeddedLS.Diagnostic[]) => void) | undefined) => Promise<embeddedLS.Diagnostic[]>;
        findReferences: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.Location[] | undefined>;
        findFileReferences: (uri: string) => embeddedLS.NullableResult<embeddedLS.Location[]>;
        findDefinition: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        findTypeDefinition: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        findImplementations: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.LocationLink[] | undefined>;
        prepareRename: (uri: string, position: embeddedLS.Position) => Promise<NonNullable<embeddedLS.Range | embeddedLS.ResponseError<void> | null | undefined> | undefined>;
        doRename: (uri: string, position: embeddedLS.Position, newName: string) => Promise<embeddedLS.WorkspaceEdit | undefined>;
        getEditsForFileRename: (oldUri: string, newUri: string) => Promise<embeddedLS.WorkspaceEdit | undefined>;
        getSemanticTokens: (uri: string, range: embeddedLS.Range | undefined, legend: embeddedLS.SemanticTokensLegend, cancelToken: embeddedLS.CancellationToken, reportProgress?: ((tokens: embeddedLS.SemanticToken[]) => void) | undefined) => Promise<embeddedLS.SemanticToken[] | undefined> | undefined;
        doHover: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.Hover | undefined>;
        doComplete: (uri: string, position: embeddedLS.Position, completionContext?: embeddedLS.CompletionContext | undefined) => Promise<embeddedLS.CompletionList>;
        doCodeActions: (uri: string, range: embeddedLS.Range, codeActionContext: embeddedLS.CodeActionContext) => Promise<embeddedLS.CodeAction[] | undefined>;
        doCodeActionResolve: (item: embeddedLS.CodeAction) => Promise<embeddedLS.CodeAction>;
        doCompletionResolve: (item: embeddedLS.CompletionItem) => Promise<embeddedLS.CompletionItem>;
        getSignatureHelp: (uri: string, position: embeddedLS.Position, signatureHelpContext?: embeddedLS.SignatureHelpContext | undefined) => Promise<embeddedLS.SignatureHelp | undefined>;
        doCodeLens: (uri: string) => Promise<embeddedLS.CodeLens[]>;
        doCodeLensResolve: (item: embeddedLS.CodeLens) => Promise<embeddedLS.CodeLens>;
        findDocumentHighlights: (uri: string, position: embeddedLS.Position) => Promise<embeddedLS.DocumentHighlight[] | undefined>;
        findDocumentLinks: (uri: string) => Promise<embeddedLS.DocumentLink[]>;
        findWorkspaceSymbols: (query: string) => Promise<embeddedLS.SymbolInformation[]>;
        doAutoInsert: (uri: string, position: embeddedLS.Position, autoInsertContext: {
            lastChange: {
                range: embeddedLS.Range;
                rangeOffset: number;
                rangeLength: number;
                text: string;
            };
        }) => Promise<NonNullable<string | embeddedLS.TextEdit | null | undefined> | undefined>;
        doExecuteCommand: (command: string, args: embeddedLS.ExecutePluginCommandArgs, executeCommandContext: embeddedLS.ExecuteCommandContext) => Promise<void>;
        getInlayHints: (uri: string, range: embeddedLS.Range) => Promise<embeddedLS.InlayHint[] | undefined>;
        callHierarchy: {
            doPrepare(uri: string, position: embeddedLS.Position): Promise<embeddedLS.CallHierarchyItem[] | undefined>;
            getIncomingCalls(item: embeddedLS.CallHierarchyItem): Promise<embeddedLS.CallHierarchyIncomingCall[]>;
            getOutgoingCalls(item: embeddedLS.CallHierarchyItem): Promise<embeddedLS.CallHierarchyOutgoingCall[]>;
        };
        dispose: () => void;
        context: embeddedLS.LanguageServiceRuntimeContext;
    } | undefined;
    getParsedCommandLine: () => ts.ParsedCommandLine;
    tryAddFile: (fileName: string) => void;
    dispose: () => void;
}>;

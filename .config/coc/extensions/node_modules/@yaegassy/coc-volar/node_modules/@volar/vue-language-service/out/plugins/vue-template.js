var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vue = require("@volar/vue-language-core");
const shared_1 = require("@vue/shared");
const html = require("vscode-html-languageservice");
const vscode = require("vscode-languageserver-protocol");
const helpers_1 = require("../helpers");
const casing = require("../ideFeatures/nameCasing");
const types_1 = require("../types");
const globalDirectives = html.newHTMLDataProvider('vue-global-directive', {
    version: 1.1,
    tags: [],
    globalAttributes: [
        { name: 'v-if' },
        { name: 'v-else-if' },
        { name: 'v-else', valueSet: 'v' },
        { name: 'v-for' },
    ],
});
// https://v3.vuejs.org/api/directives.html#v-on
const eventModifiers = {
    stop: 'call event.stopPropagation().',
    prevent: 'call event.preventDefault().',
    capture: 'add event listener in capture mode.',
    self: 'only trigger handler if event was dispatched from this element.',
    // {keyAlias}: 'only trigger handler on certain keys.',
    once: 'trigger handler at most once.',
    left: 'only trigger handler for left button mouse events.',
    right: 'only trigger handler for right button mouse events.',
    middle: 'only trigger handler for middle button mouse events.',
    passive: 'attaches a DOM event with { passive: true }.',
};
function useVueTemplateLanguagePlugin(options) {
    var _a, _b;
    const vueCompilerOptions = vue.resolveVueCompilerOptions(options.vueLsHost.getVueCompilationSettings());
    const nativeTags = new Set(vueCompilerOptions.nativeTags);
    let context;
    return Object.assign(Object.assign({}, options.templateLanguagePlugin), { setup(_context) {
            var _a, _b;
            (_b = (_a = options.templateLanguagePlugin).setup) === null || _b === void 0 ? void 0 : _b.call(_a, _context);
            context = _context;
        }, complete: {
            triggerCharacters: [
                ...(_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.triggerCharacters) !== null && _b !== void 0 ? _b : [],
                '@', // vue event shorthand
            ],
            on(document, position, context) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (!options.isSupportedDocument(document))
                        return;
                    for (const [_, map] of options.context.documents.getMapsByVirtualFileUri(document.uri)) {
                        const virtualFile = options.context.documents.getRootFileBySourceFileUri(map.sourceFileDocument.uri);
                        if (virtualFile && virtualFile instanceof vue.VueFile) {
                            yield provideHtmlData(map, virtualFile);
                        }
                    }
                    const htmlComplete = yield ((_b = (_a = options.templateLanguagePlugin.complete) === null || _a === void 0 ? void 0 : _a.on) === null || _b === void 0 ? void 0 : _b.call(_a, document, position, context));
                    if (!htmlComplete)
                        return;
                    for (const [_, map] of options.context.documents.getMapsByVirtualFileUri(document.uri)) {
                        const virtualFile = options.context.documents.getRootFileBySourceFileUri(map.sourceFileDocument.uri);
                        if (virtualFile && virtualFile instanceof vue.VueFile) {
                            afterHtmlCompletion(htmlComplete, map, virtualFile);
                        }
                    }
                    return htmlComplete;
                });
            },
        }, doHover(document, position) {
            var _a, _b;
            if (!options.isSupportedDocument(document))
                return;
            if (options.context.documents.getVirtualFileByUri(document.uri))
                options.templateLanguagePlugin.updateCustomData([]);
            return (_b = (_a = options.templateLanguagePlugin).doHover) === null || _b === void 0 ? void 0 : _b.call(_a, document, position);
        }, validation: {
            onSyntactic(document) {
                var _a, _b;
                return __awaiter(this, void 0, void 0, function* () {
                    if (!options.isSupportedDocument(document))
                        return;
                    const originalResult = yield ((_b = (_a = options.templateLanguagePlugin.validation) === null || _a === void 0 ? void 0 : _a.onSyntactic) === null || _b === void 0 ? void 0 : _b.call(_a, document));
                    for (const [_, map] of options.context.documents.getMapsByVirtualFileUri(document.uri)) {
                        const virtualFile = options.context.documents.getRootFileBySourceFileUri(map.sourceFileDocument.uri);
                        if (!virtualFile || !(virtualFile instanceof vue.VueFile))
                            continue;
                        const templateErrors = [];
                        const sfcVueTemplateCompiled = virtualFile.compiledSFCTemplate;
                        if (sfcVueTemplateCompiled) {
                            for (const error of sfcVueTemplateCompiled.errors) {
                                onCompilerError(error, vscode.DiagnosticSeverity.Error);
                            }
                            for (const warning of sfcVueTemplateCompiled.warnings) {
                                onCompilerError(warning, vscode.DiagnosticSeverity.Warning);
                            }
                            function onCompilerError(error, severity) {
                                var _a, _b, _c, _d;
                                const templateHtmlRange = {
                                    start: (_b = (_a = error.loc) === null || _a === void 0 ? void 0 : _a.start.offset) !== null && _b !== void 0 ? _b : 0,
                                    end: (_d = (_c = error.loc) === null || _c === void 0 ? void 0 : _c.end.offset) !== null && _d !== void 0 ? _d : 0,
                                };
                                let errorMessage = error.message;
                                templateErrors.push({
                                    range: {
                                        start: document.positionAt(templateHtmlRange.start),
                                        end: document.positionAt(templateHtmlRange.end),
                                    },
                                    severity,
                                    code: error.code,
                                    source: 'vue',
                                    message: errorMessage,
                                });
                            }
                        }
                        return [
                            ...originalResult !== null && originalResult !== void 0 ? originalResult : [],
                            ...templateErrors,
                        ];
                    }
                });
            },
        }, findDocumentSemanticTokens(document, range, legend) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                if (!options.isSupportedDocument(document))
                    return;
                const result = (_c = yield ((_b = (_a = options.templateLanguagePlugin).findDocumentSemanticTokens) === null || _b === void 0 ? void 0 : _b.call(_a, document, range, legend))) !== null && _c !== void 0 ? _c : [];
                const scanner = options.getScanner(document);
                if (!scanner)
                    return;
                for (const [_, map] of options.context.documents.getMapsByVirtualFileUri(document.uri)) {
                    const virtualFile = options.context.documents.getRootFileBySourceFileUri(map.sourceFileDocument.uri);
                    if (!virtualFile || !(virtualFile instanceof vue.VueFile))
                        continue;
                    const templateScriptData = (0, helpers_1.checkComponentNames)(context.typescript.module, context.typescript.languageService, virtualFile);
                    const components = new Set([
                        ...templateScriptData,
                        ...templateScriptData.map(shared_1.hyphenate).filter(name => !nativeTags.has(name)),
                    ]);
                    const offsetRange = {
                        start: document.offsetAt(range.start),
                        end: document.offsetAt(range.end),
                    };
                    let token = scanner.scan();
                    while (token !== html.TokenType.EOS) {
                        const tokenOffset = scanner.getTokenOffset();
                        // TODO: fix source map perf and break in while condition
                        if (tokenOffset > offsetRange.end)
                            break;
                        if (tokenOffset >= offsetRange.start && (token === html.TokenType.StartTag || token === html.TokenType.EndTag)) {
                            const tokenText = scanner.getTokenText();
                            if (components.has(tokenText) || tokenText.indexOf('.') >= 0) {
                                const tokenLength = scanner.getTokenLength();
                                const tokenPosition = document.positionAt(tokenOffset);
                                if (components.has(tokenText)) {
                                    let tokenType = legend.tokenTypes.indexOf('component');
                                    if (tokenType === -1) {
                                        tokenType = legend.tokenTypes.indexOf('class');
                                    }
                                    result.push([tokenPosition.line, tokenPosition.character, tokenLength, tokenType, 0]);
                                }
                            }
                        }
                        token = scanner.scan();
                    }
                }
                return result;
            });
        } });
    function provideHtmlData(map, vueSourceFile) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const detected = casing.detect(options.context, map.sourceFileDocument.uri);
            const [attr, tag] = yield Promise.all([
                (_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.completion.preferredAttrNameCase', map.sourceFileDocument.uri),
                (_b = context.env.configurationHost) === null || _b === void 0 ? void 0 : _b.getConfiguration('volar.completion.preferredTagNameCase', map.sourceFileDocument.uri),
            ]);
            const tagNameCasing = detected.tag.length === 1 && (tag === 'auto-pascal' || tag === 'auto-kebab') ? detected.tag[0] : (tag === 'auto-kebab' || tag === 'kebab') ? types_1.TagNameCasing.Kebab : types_1.TagNameCasing.Pascal;
            const attrNameCasing = detected.attr.length === 1 && (attr === 'auto-camel' || attr === 'auto-kebab') ? detected.attr[0] : (attr === 'auto-camel' || attr === 'camel') ? types_1.AttrNameCasing.Camel : types_1.AttrNameCasing.Kebab;
            options.templateLanguagePlugin.updateCustomData([
                globalDirectives,
                {
                    getId: () => 'vue-template',
                    isApplicable: () => true,
                    provideTags: () => {
                        var _a;
                        const components = (0, helpers_1.checkComponentNames)(context.typescript.module, context.typescript.languageService, vueSourceFile);
                        const scriptSetupRanges = vueSourceFile.sfc.scriptSetupAst ? vue.parseScriptSetupRanges(context.typescript.module, vueSourceFile.sfc.scriptSetupAst) : undefined;
                        const names = new Set();
                        const tags = [];
                        for (const tag of components) {
                            if (tagNameCasing === types_1.TagNameCasing.Kebab) {
                                names.add((0, shared_1.hyphenate)(tag));
                            }
                            else if (tagNameCasing === types_1.TagNameCasing.Pascal) {
                                names.add(tag);
                            }
                        }
                        for (const binding of (_a = scriptSetupRanges === null || scriptSetupRanges === void 0 ? void 0 : scriptSetupRanges.bindings) !== null && _a !== void 0 ? _a : []) {
                            const name = vueSourceFile.sfc.scriptSetup.content.substring(binding.start, binding.end);
                            if (tagNameCasing === types_1.TagNameCasing.Kebab) {
                                names.add((0, shared_1.hyphenate)(name));
                            }
                            else if (tagNameCasing === types_1.TagNameCasing.Pascal) {
                                names.add(name);
                            }
                        }
                        for (const name of names) {
                            tags.push({
                                name: name,
                                attributes: [],
                            });
                        }
                        return tags;
                    },
                    provideAttributes: (tag) => {
                        const attrs = (0, helpers_1.getElementAttrs)(context.typescript.module, context.typescript.languageService, vueSourceFile.fileName, tag);
                        const props = new Set((0, helpers_1.checkPropsOfTag)(context.typescript.module, context.typescript.languageService, vueSourceFile, tag));
                        const events = (0, helpers_1.checkEventsOfTag)(context.typescript.module, context.typescript.languageService, vueSourceFile, tag);
                        const attributes = [];
                        for (const prop of [...props, ...attrs]) {
                            const isGlobal = !props.has(prop);
                            const name = attrNameCasing === types_1.AttrNameCasing.Camel ? prop : (0, shared_1.hyphenate)(prop);
                            if ((0, shared_1.hyphenate)(name).startsWith('on-')) {
                                const propNameBase = name.startsWith('on-')
                                    ? name.slice('on-'.length)
                                    : (name['on'.length].toLowerCase() + name.slice('onX'.length));
                                const propKey = createInternalItemId('componentEvent', [isGlobal ? '*' : tag, propNameBase]);
                                attributes.push({
                                    name: 'v-on:' + propNameBase,
                                    description: propKey,
                                }, {
                                    name: '@' + propNameBase,
                                    description: propKey,
                                });
                            }
                            {
                                const propName = name;
                                const propKey = createInternalItemId('componentProp', [isGlobal ? '*' : tag, propName]);
                                attributes.push({
                                    name: propName,
                                    description: propKey,
                                }, {
                                    name: ':' + propName,
                                    description: propKey,
                                }, {
                                    name: 'v-bind:' + propName,
                                    description: propKey,
                                });
                            }
                        }
                        for (const event of events) {
                            const name = attrNameCasing === types_1.AttrNameCasing.Camel ? event : (0, shared_1.hyphenate)(event);
                            const propKey = createInternalItemId('componentEvent', [tag, name]);
                            attributes.push({
                                name: 'v-on:' + name,
                                description: propKey,
                            });
                            attributes.push({
                                name: '@' + name,
                                description: propKey,
                            });
                        }
                        const models = [];
                        for (const prop of [...props, ...attrs]) {
                            if (prop.startsWith('onUpdate:')) {
                                const isGlobal = !props.has(prop);
                                models.push([isGlobal, prop.substring('onUpdate:'.length)]);
                            }
                        }
                        for (const event of events) {
                            if (event.startsWith('update:')) {
                                models.push([false, event.substring('update:'.length)]);
                            }
                        }
                        for (const [isGlobal, model] of models) {
                            const name = attrNameCasing === types_1.AttrNameCasing.Camel ? model : (0, shared_1.hyphenate)(model);
                            const propKey = createInternalItemId('componentProp', [isGlobal ? '*' : tag, name]);
                            attributes.push({
                                name: 'v-model:' + name,
                                description: propKey,
                            });
                            if (model === 'modelValue') {
                                attributes.push({
                                    name: 'v-model',
                                    description: propKey,
                                });
                            }
                        }
                        return attributes;
                    },
                    provideValues: () => [],
                },
            ]);
        });
    }
    function afterHtmlCompletion(completionList, map, vueSourceFile) {
        var _a, _b, _c, _d, _e, _f;
        const replacement = getReplacement(completionList, map.sourceFileDocument);
        const componentNames = new Set((0, helpers_1.checkComponentNames)(context.typescript.module, context.typescript.languageService, vueSourceFile).map(shared_1.hyphenate));
        if (replacement) {
            const isEvent = replacement.text.startsWith('@') || replacement.text.startsWith('v-on:');
            const hasModifier = replacement.text.includes('.');
            if (isEvent && hasModifier) {
                const modifiers = replacement.text.split('.').slice(1);
                const textWithoutModifier = replacement.text.split('.')[0];
                for (const modifier in eventModifiers) {
                    if (modifiers.includes(modifier))
                        continue;
                    const modifierDes = eventModifiers[modifier];
                    const newItem = {
                        label: modifier,
                        filterText: textWithoutModifier + '.' + modifier,
                        documentation: modifierDes,
                        textEdit: {
                            range: replacement.textEdit.range,
                            newText: textWithoutModifier + '.' + modifier,
                        },
                        kind: vscode.CompletionItemKind.EnumMember,
                    };
                    completionList.items.push(newItem);
                }
            }
        }
        for (const item of completionList.items) {
            const itemIdKey = typeof item.documentation === 'string' ? item.documentation : (_a = item.documentation) === null || _a === void 0 ? void 0 : _a.value;
            const itemId = itemIdKey ? readInternalItemId(itemIdKey) : undefined;
            if (itemId) {
                item.documentation = undefined;
            }
            if (itemIdKey && itemId) {
                if (itemId.type === 'componentProp' || itemId.type === 'componentEvent') {
                    const [componentName] = itemId.args;
                    if (componentName !== '*') {
                        item.sortText = '\u0000' + ((_b = item.sortText) !== null && _b !== void 0 ? _b : item.label);
                    }
                    if (itemId.type === 'componentProp') {
                        if (componentName !== '*') {
                            item.kind = vscode.CompletionItemKind.Field;
                        }
                    }
                    else {
                        item.kind = componentName !== '*' ? vscode.CompletionItemKind.Function : vscode.CompletionItemKind.Event;
                    }
                }
                else if (item.label === 'v-if'
                    || item.label === 'v-else-if'
                    || item.label === 'v-else'
                    || item.label === 'v-for') {
                    item.kind = vscode.CompletionItemKind.Method;
                    item.sortText = '\u0003' + ((_c = item.sortText) !== null && _c !== void 0 ? _c : item.label);
                }
                else if (item.label.startsWith('v-')) {
                    item.kind = vscode.CompletionItemKind.Function;
                    item.sortText = '\u0002' + ((_d = item.sortText) !== null && _d !== void 0 ? _d : item.label);
                }
                else {
                    item.sortText = '\u0001' + ((_e = item.sortText) !== null && _e !== void 0 ? _e : item.label);
                }
            }
            else if (item.kind === vscode.CompletionItemKind.Property && componentNames.has((0, shared_1.hyphenate)(item.label))) {
                item.kind = vscode.CompletionItemKind.Variable;
                item.sortText = '\u0000' + ((_f = item.sortText) !== null && _f !== void 0 ? _f : item.label);
            }
        }
        options.templateLanguagePlugin.updateCustomData([]);
    }
}
exports.default = useVueTemplateLanguagePlugin;
function createInternalItemId(type, args) {
    return '__VLS_::' + type + '::' + args.join(',');
}
function readInternalItemId(key) {
    if (key.startsWith('__VLS_::')) {
        const strs = key.split('::');
        return {
            type: strs[1],
            args: strs[2].split(','),
        };
    }
}
function getReplacement(list, doc) {
    for (const item of list.items) {
        if (item.textEdit && 'range' in item.textEdit) {
            return {
                item: item,
                textEdit: item.textEdit,
                text: doc.getText(item.textEdit.range)
            };
        }
    }
}
//# sourceMappingURL=vue-template.js.map
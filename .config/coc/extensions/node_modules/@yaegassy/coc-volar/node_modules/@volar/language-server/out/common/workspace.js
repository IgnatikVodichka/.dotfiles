var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortTsConfigs = exports.createWorkspace = exports.rootTsConfigNames = void 0;
const shared = require("@volar/shared");
const path = require("typesafe-path");
const vscode = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const project_1 = require("./project");
const inferredCompilerOptions_1 = require("./utils/inferredCompilerOptions");
const serverConfig_1 = require("./utils/serverConfig");
const uriMap_1 = require("./utils/uriMap");
exports.rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
function createWorkspace(context) {
    return __awaiter(this, void 0, void 0, function* () {
        let inferredProject;
        const serverConfig = (0, serverConfig_1.loadServerConfig)(shared.getPathOfUri(context.rootUri.toString()), context.workspaces.initOptions.configFilePath);
        const sys = context.workspaces.fileSystemHost.getWorkspaceFileSystem(context.rootUri);
        const documentRegistry = context.workspaces.ts.createDocumentRegistry(sys.useCaseSensitiveFileNames, shared.getPathOfUri(context.rootUri.toString()));
        const projects = (0, uriMap_1.createUriMap)();
        const rootTsConfigs = new Set(sys.readDirectory(shared.getPathOfUri(context.rootUri.toString()), exports.rootTsConfigNames, undefined, ['**/*']).map(fileName => shared.normalizeFileName(fileName)));
        const disposeTsConfigWatch = context.workspaces.fileSystemHost.onDidChangeWatchedFiles(({ changes }) => {
            for (const change of changes) {
                if (exports.rootTsConfigNames.includes(change.uri.substring(change.uri.lastIndexOf('/') + 1))) {
                    if (change.type === vscode.FileChangeType.Created) {
                        if (shared.isFileInDir(shared.getPathOfUri(change.uri), shared.getPathOfUri(context.rootUri.toString()))) {
                            rootTsConfigs.add(shared.getPathOfUri(change.uri));
                        }
                    }
                    else if ((change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Deleted) && projects.uriHas(change.uri)) {
                        if (change.type === vscode.FileChangeType.Deleted) {
                            rootTsConfigs.delete(shared.getPathOfUri(change.uri));
                        }
                        const project = projects.uriGet(change.uri);
                        projects.uriDelete(change.uri);
                        project === null || project === void 0 ? void 0 : project.then(project => project.dispose());
                    }
                }
            }
        });
        return {
            projects,
            documentRegistry,
            getProjectAndTsConfig,
            getInferredProject,
            getInferredProjectDontCreate: () => inferredProject,
            reload: clearProjects,
            dispose() {
                clearProjects();
                disposeTsConfigWatch();
            },
        };
        function clearProjects() {
            const _projects = [
                inferredProject,
                ...projects.values(),
            ];
            _projects.forEach((project) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                (_a = (yield project)) === null || _a === void 0 ? void 0 : _a.dispose();
            }));
            inferredProject = undefined;
            projects.clear();
        }
        function getProjectAndTsConfig(uri) {
            return __awaiter(this, void 0, void 0, function* () {
                const tsconfig = yield findMatchConfigs(vscode_uri_1.URI.parse(uri));
                if (tsconfig) {
                    const project = yield getProjectByCreate(tsconfig);
                    return {
                        tsconfig: tsconfig,
                        project,
                    };
                }
            });
        }
        function getInferredProject() {
            if (!inferredProject) {
                inferredProject = (() => __awaiter(this, void 0, void 0, function* () {
                    const inferOptions = yield (0, inferredCompilerOptions_1.getInferredCompilerOptions)(context.workspaces.ts, context.workspaces.configurationHost);
                    return (0, project_1.createProject)({
                        workspace: context,
                        rootUri: context.rootUri,
                        tsConfig: inferOptions,
                        documentRegistry,
                        serverConfig,
                    });
                }))();
            }
            return inferredProject;
        }
        function findMatchConfigs(uri) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield prepareClosestootParsedCommandLine();
                return (_a = yield findDirectIncludeTsconfig()) !== null && _a !== void 0 ? _a : yield findIndirectReferenceTsconfig();
                function prepareClosestootParsedCommandLine() {
                    return __awaiter(this, void 0, void 0, function* () {
                        let matches = [];
                        for (const rootTsConfig of rootTsConfigs) {
                            if (shared.isFileInDir(shared.getPathOfUri(uri.toString()), path.dirname(rootTsConfig))) {
                                matches.push(rootTsConfig);
                            }
                        }
                        matches = matches.sort((a, b) => sortTsConfigs(shared.getPathOfUri(uri.toString()), a, b));
                        if (matches.length) {
                            yield getParsedCommandLine(matches[0]);
                        }
                    });
                }
                function findDirectIncludeTsconfig() {
                    return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                        const map = (0, uriMap_1.createUriMap)();
                        const parsedCommandLine = yield getParsedCommandLine(tsconfig);
                        for (const fileName of parsedCommandLine.fileNames) {
                            map.pathSet(fileName, true);
                        }
                        return map.uriHas(uri.toString());
                    }));
                }
                function findIndirectReferenceTsconfig() {
                    return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const project = yield projects.pathGet(tsconfig);
                        const ls = project === null || project === void 0 ? void 0 : project.getLanguageServiceDontCreate();
                        const validDoc = (_a = ls === null || ls === void 0 ? void 0 : ls.context.typescriptLanguageService.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(shared.getPathOfUri(uri.toString()));
                        return !!validDoc;
                    }));
                }
                function findTsconfig(match) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const checked = new Set();
                        for (const rootTsConfig of [...rootTsConfigs].sort((a, b) => sortTsConfigs(shared.getPathOfUri(uri.toString()), a, b))) {
                            const project = yield projects.pathGet(rootTsConfig);
                            if (project) {
                                let chains = yield getReferencesChains(project.getParsedCommandLine(), rootTsConfig, []);
                                if (context.workspaces.initOptions.reverseConfigFilePriority) {
                                    chains = chains.reverse();
                                }
                                for (const chain of chains) {
                                    for (let i = chain.length - 1; i >= 0; i--) {
                                        const tsconfig = chain[i];
                                        if (checked.has(tsconfig))
                                            continue;
                                        checked.add(tsconfig);
                                        if (yield match(tsconfig)) {
                                            return tsconfig;
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                function getReferencesChains(parsedCommandLine, tsConfig, before) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        if ((_a = parsedCommandLine.projectReferences) === null || _a === void 0 ? void 0 : _a.length) {
                            const newChains = [];
                            for (const projectReference of parsedCommandLine.projectReferences) {
                                let tsConfigPath = projectReference.path;
                                // fix https://github.com/johnsoncodehk/volar/issues/712
                                if (!sys.fileExists(tsConfigPath)) {
                                    const newTsConfigPath = path.join(tsConfigPath, 'tsconfig.json');
                                    const newJsConfigPath = path.join(tsConfigPath, 'jsconfig.json');
                                    if (sys.fileExists(newTsConfigPath)) {
                                        tsConfigPath = newTsConfigPath;
                                    }
                                    else if (sys.fileExists(newJsConfigPath)) {
                                        tsConfigPath = newJsConfigPath;
                                    }
                                }
                                const beforeIndex = before.indexOf(tsConfigPath); // cycle
                                if (beforeIndex >= 0) {
                                    newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
                                }
                                else {
                                    const referenceParsedCommandLine = yield getParsedCommandLine(tsConfigPath);
                                    for (const chain of yield getReferencesChains(referenceParsedCommandLine, tsConfigPath, [...before, tsConfig])) {
                                        newChains.push(chain);
                                    }
                                }
                            }
                            return newChains;
                        }
                        else {
                            return [[...before, tsConfig]];
                        }
                    });
                }
                function getParsedCommandLine(tsConfig) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const project = yield getProjectByCreate(tsConfig);
                        return project.getParsedCommandLine();
                    });
                }
            });
        }
        function getProjectByCreate(_tsConfig) {
            const tsConfig = shared.normalizeFileName(_tsConfig);
            let project = projects.pathGet(tsConfig);
            if (!project) {
                project = (0, project_1.createProject)({
                    workspace: context,
                    serverConfig,
                    rootUri: vscode_uri_1.URI.parse(shared.getUriByPath(path.dirname(tsConfig))),
                    tsConfig,
                    documentRegistry,
                });
                projects.pathSet(tsConfig, project);
            }
            return project;
        }
    });
}
exports.createWorkspace = createWorkspace;
function sortTsConfigs(file, a, b) {
    const inA = shared.isFileInDir(file, path.dirname(a));
    const inB = shared.isFileInDir(file, path.dirname(b));
    if (inA !== inB) {
        const aWeight = inA ? 1 : 0;
        const bWeight = inB ? 1 : 0;
        return bWeight - aWeight;
    }
    const aLength = a.split('/').length;
    const bLength = b.split('/').length;
    if (aLength === bLength) {
        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
        return bWeight - aWeight;
    }
    return bLength - aLength;
}
exports.sortTsConfigs = sortTsConfigs;
//# sourceMappingURL=workspace.js.map
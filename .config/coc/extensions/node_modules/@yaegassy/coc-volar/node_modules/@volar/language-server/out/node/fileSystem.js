var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeFileSystemHost = void 0;
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver");
const uriMap_1 = require("../common/utils/uriMap");
let currentCwd = '';
function createNodeFileSystemHost(ts, capabilities) {
    const instances = (0, uriMap_1.createUriMap)();
    const onDidChangeWatchedFilesCb = new Set();
    return {
        ready(connection) {
            connection.onDidChangeWatchedFiles((params) => __awaiter(this, void 0, void 0, function* () {
                if (params.changes.some(change => change.type === vscode.FileChangeType.Created || change.type === vscode.FileChangeType.Deleted)) {
                    for (const sys of instances.values()) {
                        sys[1].forEach(cache => cache.clear());
                    }
                }
                for (const cb of [...onDidChangeWatchedFilesCb]) {
                    if (onDidChangeWatchedFilesCb.has(cb)) {
                        yield cb(params);
                    }
                }
            }));
        },
        reload() {
            for (const sys of instances.values()) {
                sys[1].forEach(cache => cache.clear());
            }
        },
        getWorkspaceFileSystem(rootUri) {
            let sys = instances.uriGet(rootUri.toString());
            if (!sys) {
                sys = createWorkspaceFileSystem(ts, capabilities, rootUri);
                instances.uriSet(rootUri.toString(), sys);
            }
            return sys[0];
        },
        onDidChangeWatchedFiles: cb => {
            onDidChangeWatchedFilesCb.add(cb);
            return () => onDidChangeWatchedFilesCb.delete(cb);
        },
    };
    function createWorkspaceFileSystem(ts, capabilities, rootUri) {
        var _a;
        const rootPath = shared.getPathOfUri(rootUri.toString());
        const workspaceSys = new Proxy(ts.sys, {
            get(target, prop) {
                const fn = target[prop];
                if (typeof fn === 'function') {
                    return new Proxy(fn, {
                        apply(target, thisArg, args) {
                            if (currentCwd !== rootPath) {
                                if (ts.sys.directoryExists(rootPath)) { // #2234, #2039
                                    process.chdir(rootPath);
                                }
                                currentCwd = rootPath;
                            }
                            return target.apply(thisArg, args);
                        }
                    });
                }
                return fn;
            },
        });
        const fileExistsCache = new Map();
        const directoryExistsCache = new Map();
        // don't cache fs result if client did not supports file watcher
        const sys = ((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.didChangeWatchedFiles)
            ? new Proxy({
                fileExists(path) {
                    if (!fileExistsCache.has(path)) {
                        fileExistsCache.set(path, workspaceSys.fileExists(path));
                    }
                    return fileExistsCache.get(path);
                },
                directoryExists(path) {
                    if (!directoryExistsCache.has(path)) {
                        directoryExistsCache.set(path, workspaceSys.directoryExists(path));
                    }
                    return directoryExistsCache.get(path);
                },
            }, {
                get(target, prop) {
                    if (prop in target) {
                        return target[prop];
                    }
                    return workspaceSys[prop];
                },
            })
            : workspaceSys;
        return [sys, [fileExistsCache, directoryExistsCache]];
    }
}
exports.createNodeFileSystemHost = createNodeFileSystemHost;
//# sourceMappingURL=fileSystem.js.map
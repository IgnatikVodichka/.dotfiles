var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const embedded = require("@volar/language-service");
const vscode = require("vscode-languageserver");
const protocol_1 = require("../../protocol");
const shared = require("@volar/shared");
function register(connection, projects, initParams, cancelHost, semanticTokensLegend) {
    let lastCompleteUri;
    let lastCompleteLs;
    let lastCodeLensLs;
    let lastCodeActionLs;
    let lastCallHierarchyLs;
    connection.onCompletion((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            lastCompleteUri = params.textDocument.uri;
            lastCompleteLs = vueLs;
            const list = yield vueLs.doComplete(params.textDocument.uri, params.position, params.context);
            if (list) {
                for (const item of list.items) {
                    fixTextEdit(item);
                }
            }
            return list;
        }));
    }));
    connection.onCompletionResolve((item) => __awaiter(this, void 0, void 0, function* () {
        if (lastCompleteUri && lastCompleteLs) {
            item = yield lastCompleteLs.doCompletionResolve(item);
            fixTextEdit(item);
        }
        return item;
    }));
    connection.onHover((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.doHover(params.textDocument.uri, params.position);
        });
    }));
    connection.onSignatureHelp((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.getSignatureHelp(params.textDocument.uri, params.position, params.context);
        });
    }));
    connection.onPrepareRename((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.prepareRename(params.textDocument.uri, params.position);
        });
    }));
    connection.onRenameRequest((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.doRename(params.textDocument.uri, params.position, params.newName);
        });
    }));
    connection.onCodeLens((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            lastCodeLensLs = vueLs;
            return vueLs.doCodeLens(params.textDocument.uri);
        }));
    }));
    connection.onCodeLensResolve((codeLens) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = yield (lastCodeLensLs === null || lastCodeLensLs === void 0 ? void 0 : lastCodeLensLs.doCodeLensResolve(codeLens))) !== null && _a !== void 0 ? _a : codeLens;
    }));
    connection.onExecuteCommand((params, token, workDoneProgress) => __awaiter(this, void 0, void 0, function* () {
        if (params.command === embedded.executePluginCommand) {
            const args = params.arguments;
            if (!args) {
                return;
            }
            return worker(args[0], vueLs => {
                return vueLs.doExecuteCommand(params.command, args, {
                    token,
                    workDoneProgress,
                    applyEdit: (paramOrEdit) => connection.workspace.applyEdit(paramOrEdit),
                    showReferences: (params) => connection.sendNotification(protocol_1.ShowReferencesNotification.type, params),
                });
            });
        }
    }));
    connection.onCodeAction((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _b, _c, _d;
            lastCodeActionLs = vueLs;
            let codeActions = (_b = yield vueLs.doCodeActions(params.textDocument.uri, params.range, params.context)) !== null && _b !== void 0 ? _b : [];
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.uri = params.textDocument.uri;
                }
                else {
                    codeAction.data = { uri: params.textDocument.uri };
                }
            }
            if (!((_d = (_c = initParams.capabilities.textDocument) === null || _c === void 0 ? void 0 : _c.codeAction) === null || _d === void 0 ? void 0 : _d.disabledSupport)) {
                codeActions = codeActions.filter(codeAction => !codeAction.disabled);
            }
            return codeActions;
        }));
    }));
    connection.onCodeActionResolve((codeAction) => __awaiter(this, void 0, void 0, function* () {
        var _e;
        return (_e = yield lastCodeActionLs.doCodeActionResolve(codeAction)) !== null && _e !== void 0 ? _e : codeAction;
    }));
    connection.onReferences((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findReferences(params.textDocument.uri, params.position);
        });
    }));
    connection.onRequest(protocol_1.FindFileReferenceRequest.type, (params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findFileReferences(params.textDocument.uri);
        });
    }));
    connection.onImplementation((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findImplementations(params.textDocument.uri, params.position);
        });
    }));
    connection.onDefinition((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findDefinition(params.textDocument.uri, params.position);
        });
    }));
    connection.onTypeDefinition((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findTypeDefinition(params.textDocument.uri, params.position);
        });
    }));
    connection.onDocumentHighlight((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findDocumentHighlights(params.textDocument.uri, params.position);
        });
    }));
    connection.onDocumentLinks((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.findDocumentLinks(params.textDocument.uri);
        });
    }));
    connection.onWorkspaceSymbol((params, token) => __awaiter(this, void 0, void 0, function* () {
        let results = [];
        for (const _workspace of projects.workspaces.values()) {
            const workspace = yield _workspace;
            let projects = [...workspace.projects.values()];
            projects = projects.length ? projects : [workspace.getInferredProject()];
            for (const project of projects) {
                if (token.isCancellationRequested)
                    return;
                const vueLs = (yield project).getLanguageService();
                results = results.concat(yield vueLs.findWorkspaceSymbols(params.query));
            }
        }
        return results;
    }));
    connection.languages.callHierarchy.onPrepare((params) => __awaiter(this, void 0, void 0, function* () {
        var _f;
        return (_f = yield worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            lastCallHierarchyLs = vueLs;
            return vueLs.callHierarchy.doPrepare(params.textDocument.uri, params.position);
        }))) !== null && _f !== void 0 ? _f : [];
    }));
    connection.languages.callHierarchy.onIncomingCalls((params) => __awaiter(this, void 0, void 0, function* () {
        var _g;
        return (_g = yield (lastCallHierarchyLs === null || lastCallHierarchyLs === void 0 ? void 0 : lastCallHierarchyLs.callHierarchy.getIncomingCalls(params.item))) !== null && _g !== void 0 ? _g : [];
    }));
    connection.languages.callHierarchy.onOutgoingCalls((params) => __awaiter(this, void 0, void 0, function* () {
        var _h;
        return (_h = yield (lastCallHierarchyLs === null || lastCallHierarchyLs === void 0 ? void 0 : lastCallHierarchyLs.callHierarchy.getOutgoingCalls(params.item))) !== null && _h !== void 0 ? _h : [];
    }));
    connection.languages.semanticTokens.on((params, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _j;
        yield shared.sleep(200);
        if (token.isCancellationRequested)
            return buildTokens([]);
        return (_j = yield worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _k;
            const result = (_k = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(params.textDocument.uri, undefined, semanticTokensLegend, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _k !== void 0 ? _k : [];
            return buildTokens(result);
        }))) !== null && _j !== void 0 ? _j : buildTokens([]);
    }));
    connection.languages.semanticTokens.onRange((params, token, _, resultProgress) => __awaiter(this, void 0, void 0, function* () {
        var _l;
        yield shared.sleep(200);
        if (token.isCancellationRequested)
            return buildTokens([]);
        return (_l = yield worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            var _m;
            const result = (_m = yield (vueLs === null || vueLs === void 0 ? void 0 : vueLs.getSemanticTokens(params.textDocument.uri, params.range, semanticTokensLegend, token, tokens => resultProgress === null || resultProgress === void 0 ? void 0 : resultProgress.report(buildTokens(tokens))))) !== null && _m !== void 0 ? _m : [];
            return buildTokens(result);
        }))) !== null && _l !== void 0 ? _l : buildTokens([]);
    }));
    connection.languages.diagnostics.on((params, token, _workDoneProgressReporter, resultProgressReporter) => __awaiter(this, void 0, void 0, function* () {
        token = cancelHost.createCancellationToken(token);
        const result = yield worker(params.textDocument.uri, vueLs => {
            return vueLs.doValidation(params.textDocument.uri, token, errors => {
                // resultProgressReporter is undefined in vscode
                resultProgressReporter === null || resultProgressReporter === void 0 ? void 0 : resultProgressReporter.report({
                    relatedDocuments: {
                        [params.textDocument.uri]: {
                            kind: vscode.DocumentDiagnosticReportKind.Full,
                            items: errors,
                        },
                    },
                });
            });
        });
        return {
            kind: vscode.DocumentDiagnosticReportKind.Full,
            items: result !== null && result !== void 0 ? result : [],
        };
    }));
    connection.languages.inlayHint.on((params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, (vueLs) => __awaiter(this, void 0, void 0, function* () {
            return vueLs.getInlayHints(params.textDocument.uri, params.range);
        }));
    }));
    // TODO: connection.languages.inlayHint.resolve
    connection.workspace.onWillRenameFiles((params) => __awaiter(this, void 0, void 0, function* () {
        var _o;
        const config = yield connection.workspace.getConfiguration('volar.updateImportsOnFileMove.enabled');
        if (!config) {
            return null;
        }
        if (params.files.length !== 1) {
            return null;
        }
        const file = params.files[0];
        return (_o = yield worker(file.oldUri, vueLs => {
            var _a;
            return (_a = vueLs.getEditsForFileRename(file.oldUri, file.newUri)) !== null && _a !== void 0 ? _a : null;
        })) !== null && _o !== void 0 ? _o : null;
    }));
    connection.onRequest(protocol_1.AutoInsertRequest.type, (params) => __awaiter(this, void 0, void 0, function* () {
        return worker(params.textDocument.uri, vueLs => {
            return vueLs.doAutoInsert(params.textDocument.uri, params.position, params.options);
        });
    }));
    function worker(uri, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const vueLs = yield getLanguageService(uri);
            if (vueLs) {
                try {
                    return cb(vueLs); // handle for TS cancel throw
                }
                catch (_a) {
                    return undefined;
                }
            }
        });
    }
    function buildTokens(tokens) {
        const builder = new vscode.SemanticTokensBuilder();
        const sortedTokens = tokens.sort((a, b) => a[0] - b[0] === 0 ? a[1] - b[1] : a[0] - b[0]);
        for (const token of sortedTokens) {
            builder.push(...token);
        }
        return builder.build();
    }
    function getLanguageService(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const project = (_a = (yield projects.getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
            return project === null || project === void 0 ? void 0 : project.getLanguageService();
        });
    }
    function fixTextEdit(item) {
        var _a, _b, _c, _d;
        const insertReplaceSupport = (_d = (_c = (_b = (_a = initParams.capabilities.textDocument) === null || _a === void 0 ? void 0 : _a.completion) === null || _b === void 0 ? void 0 : _b.completionItem) === null || _c === void 0 ? void 0 : _c.insertReplaceSupport) !== null && _d !== void 0 ? _d : false;
        if (!insertReplaceSupport) {
            if (item.textEdit && vscode.InsertReplaceEdit.is(item.textEdit)) {
                item.textEdit = vscode.TextEdit.replace(item.textEdit.insert, item.textEdit.newText);
            }
        }
    }
}
exports.register = register;
//# sourceMappingURL=languageFeatures.js.map
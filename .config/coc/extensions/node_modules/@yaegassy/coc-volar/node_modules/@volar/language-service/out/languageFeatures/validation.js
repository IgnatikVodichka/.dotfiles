var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.updateRange = void 0;
const shared = require("@volar/shared");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
function updateRange(range, change) {
    if (!updatePosition(range.start, change, false)) {
        return;
    }
    if (!updatePosition(range.end, change, true)) {
        return;
    }
    if (range.end.line === range.start.line && range.end.character <= range.start.character) {
        range.end.character++;
    }
    return range;
}
exports.updateRange = updateRange;
function updatePosition(position, change, isEnd) {
    if (change.range.end.line > position.line) {
        if (change.newEnd.line > position.line) {
            // No change
            return true;
        }
        else if (change.newEnd.line === position.line) {
            position.character = Math.min(position.character, change.newEnd.character);
            return true;
        }
        else if (change.newEnd.line < position.line) {
            position.line = change.newEnd.line;
            position.character = change.newEnd.character;
            return true;
        }
    }
    else if (change.range.end.line === position.line) {
        const characterDiff = change.newEnd.character - change.range.end.character;
        if (position.character >= change.range.end.character) {
            if (change.newEnd.line !== change.range.end.line) {
                position.line = change.newEnd.line;
                position.character = change.newEnd.character + position.character - change.range.end.character;
            }
            else {
                if (isEnd ? change.range.end.character < position.character : change.range.end.character <= position.character) {
                    position.character += characterDiff;
                }
                else {
                    const offset = change.range.end.character - position.character;
                    if (-characterDiff > offset) {
                        position.character += characterDiff + offset;
                    }
                }
            }
            return true;
        }
        else {
            if (change.newEnd.line === change.range.end.line) {
                const offset = change.range.end.character - position.character;
                if (-characterDiff > offset) {
                    position.character += characterDiff + offset;
                }
            }
            else if (change.newEnd.line < change.range.end.line) {
                position.line = change.newEnd.line;
                position.character = change.newEnd.character;
            }
            else {
                // No change
            }
            return true;
        }
    }
    else if (change.range.end.line < position.line) {
        position.line += change.newEnd.line - change.range.end.line;
        return true;
    }
    return false;
}
function register(context) {
    const responseCache = new Map();
    const nonTsCache = new Map();
    const scriptTsCache_semantic = new Map();
    const scriptTsCache_declaration = new Map();
    const scriptTsCache_syntactic = new Map();
    const scriptTsCache_suggestion = new Map();
    return (uri, token, response) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const cache = (_a = responseCache.get(uri)) !== null && _a !== void 0 ? _a : responseCache.set(uri, {
            nonTs: { snapshot: undefined, errors: [] },
            tsSemantic: { snapshot: undefined, errors: [] },
            tsDeclaration: { snapshot: undefined, errors: [] },
            tsSuggestion: { snapshot: undefined, errors: [] },
            tsSyntactic: { snapshot: undefined, errors: [] },
        }).get(uri);
        const newSnapshot = context.host.getScriptSnapshot(shared.getPathOfUri(uri));
        const newDocument = newSnapshot ? vscode_languageserver_textdocument_1.TextDocument.create('file://a.txt', 'txt', 0, newSnapshot.getText(0, newSnapshot.getLength())) : undefined;
        let failedToUpdateRange = false;
        let errorsUpdated = false;
        let lastCheckCancelAt = 0;
        for (const _cache of Object.values(cache)) {
            const oldSnapshot = _cache.snapshot;
            const change = oldSnapshot ? newSnapshot === null || newSnapshot === void 0 ? void 0 : newSnapshot.getChangeRange(oldSnapshot) : undefined;
            _cache.snapshot = newSnapshot;
            if (!failedToUpdateRange && newDocument && oldSnapshot && newSnapshot && change) {
                const oldDocument = vscode_languageserver_textdocument_1.TextDocument.create('file://a.txt', 'txt', 0, oldSnapshot.getText(0, oldSnapshot.getLength()));
                const changeRange = {
                    range: {
                        start: oldDocument.positionAt(change.span.start),
                        end: oldDocument.positionAt(change.span.start + change.span.length),
                    },
                    newEnd: newDocument.positionAt(change.span.start + change.newLength),
                };
                for (const error of _cache.errors) {
                    if (!updateRange(error.range, changeRange)) {
                        failedToUpdateRange = true;
                        break;
                    }
                }
            }
        }
        yield worker('onSyntactic', scriptTsCache_syntactic, cache.tsSyntactic);
        doResponse();
        yield worker('onSuggestion', scriptTsCache_suggestion, cache.tsSuggestion);
        doResponse();
        yield worker('onSemantic', scriptTsCache_semantic, cache.tsSemantic);
        doResponse();
        yield worker('onDeclaration', scriptTsCache_declaration, cache.tsDeclaration);
        return getErrors();
        function doResponse() {
            if (errorsUpdated && !failedToUpdateRange) {
                response === null || response === void 0 ? void 0 : response(getErrors());
                errorsUpdated = false;
            }
        }
        function getErrors() {
            return Object.values(cache).flatMap(({ errors }) => errors);
        }
        function worker(mode, cacheMap, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield (0, featureWorkers_1.languageFeatureWorker)(context, uri, true, function* (arg, _, file) {
                    if (file.capabilities.diagnostic) {
                        yield arg;
                    }
                }, (plugin, document) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e;
                    if (token) {
                        if (Date.now() - lastCheckCancelAt >= 5) {
                            yield shared.sleep(5); // wait for LSP event polling
                            lastCheckCancelAt = Date.now();
                        }
                        if (token.isCancellationRequested)
                            return;
                    }
                    const pluginId = context.plugins.indexOf(plugin);
                    const pluginCache = (_a = cacheMap.get(pluginId)) !== null && _a !== void 0 ? _a : cacheMap.set(pluginId, new Map()).get(pluginId);
                    const cache = pluginCache.get(document.uri);
                    const tsProjectVersion = (mode === 'onDeclaration' || mode === 'onSemantic') ? (_c = (_b = context.core.typescript.languageServiceHost).getProjectVersion) === null || _c === void 0 ? void 0 : _c.call(_b) : undefined;
                    if (mode === 'onDeclaration' || mode === 'onSemantic') {
                        if (cache && cache.documentVersion === document.version && cache.tsProjectVersion === tsProjectVersion) {
                            return cache.errors;
                        }
                    }
                    else {
                        if (cache && cache.documentVersion === document.version) {
                            return cache.errors;
                        }
                    }
                    const errors = yield ((_e = (_d = plugin.validation) === null || _d === void 0 ? void 0 : _d[mode]) === null || _e === void 0 ? void 0 : _e.call(_d, document));
                    errorsUpdated = true;
                    pluginCache.set(document.uri, {
                        documentVersion: document.version,
                        errors,
                        tsProjectVersion,
                    });
                    return errors;
                }), (errors, map) => transformErrorRange(map, errors), arr => dedupe.withDiagnostics(arr.flat()));
                if (result) {
                    cache.errors = result;
                    cache.snapshot = newSnapshot;
                }
            });
        }
    });
    function transformErrorRange(map, errors) {
        const result = [];
        for (const error of errors) {
            // clone it to avoid modify cache
            let _error = Object.assign({}, error);
            if (map) {
                const range = map.toSourceRange(error.range, data => !!data.diagnostic);
                if (!range) {
                    continue;
                }
                _error.range = range;
            }
            if (_error.relatedInformation) {
                const relatedInfos = [];
                for (const info of _error.relatedInformation) {
                    if (context.documents.getVirtualFileByUri(info.location.uri)) {
                        for (const [_, map] of context.documents.getMapsByVirtualFileUri(info.location.uri)) {
                            const range = map.toSourceRange(info.location.range, data => !!data.diagnostic);
                            if (range) {
                                relatedInfos.push({
                                    location: {
                                        uri: map.sourceFileDocument.uri,
                                        range,
                                    },
                                    message: info.message,
                                });
                            }
                        }
                    }
                    else {
                        relatedInfos.push(info);
                    }
                }
                _error.relatedInformation = relatedInfos;
            }
            result.push(_error);
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=validation.js.map
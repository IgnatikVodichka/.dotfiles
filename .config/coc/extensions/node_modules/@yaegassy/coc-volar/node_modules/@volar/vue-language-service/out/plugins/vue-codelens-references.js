var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.commands = void 0;
const vue_language_core_1 = require("@volar/vue-language-core");
const showReferencesCommand = 'volar.show-references';
exports.commands = [showReferencesCommand];
function default_1(options) {
    let context;
    return {
        setup(_context) {
            context = _context;
        },
        codeLens: {
            on(document) {
                return worker(document.uri, () => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d;
                    const isEnabled = (_b = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.codeLens.references'))) !== null && _b !== void 0 ? _b : true;
                    if (!isEnabled)
                        return;
                    const result = [];
                    for (const [_, map] of (_d = (_c = options.documents.getMapsBySourceFileUri(document.uri)) === null || _c === void 0 ? void 0 : _c.maps) !== null && _d !== void 0 ? _d : []) {
                        for (const mapping of map.map.mappings) {
                            if (!mapping.data.referencesCodeLens)
                                continue;
                            result.push({
                                range: {
                                    start: document.positionAt(mapping.sourceRange[0]),
                                    end: document.positionAt(mapping.sourceRange[1]),
                                },
                                data: {
                                    uri: document.uri,
                                    position: document.positionAt(mapping.sourceRange[0]),
                                },
                            });
                        }
                    }
                    return result;
                }));
            },
            resolve(codeLens) {
                return __awaiter(this, void 0, void 0, function* () {
                    const data = codeLens.data;
                    yield worker(data.uri, (vueFile) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const document = options.documents.getDocumentByFileName(vueFile.snapshot, vueFile.fileName);
                        const offset = document.offsetAt(data.position);
                        const blocks = [
                            vueFile.sfc.script,
                            vueFile.sfc.scriptSetup,
                            vueFile.sfc.template,
                            ...vueFile.sfc.styles,
                            ...vueFile.sfc.customBlocks,
                        ];
                        const allRefs = (_a = yield options.findReference(data.uri, data.position)) !== null && _a !== void 0 ? _a : [];
                        const sourceBlock = blocks.find(block => block && offset >= block.startTagEnd && offset <= block.endTagStart);
                        const diffDocRefs = allRefs.filter(reference => reference.uri !== data.uri // different file
                            || sourceBlock !== blocks.find(block => block && document.offsetAt(reference.range.start) >= block.startTagEnd && document.offsetAt(reference.range.end) <= block.endTagStart) // different block
                        );
                        codeLens.command = {
                            title: diffDocRefs.length === 1 ? '1 reference' : `${diffDocRefs.length} references`,
                            command: showReferencesCommand,
                            arguments: [data.uri, codeLens.range.start, diffDocRefs],
                        };
                    }));
                    return codeLens;
                });
            },
        },
        doExecuteCommand(command, args, context) {
            if (command === showReferencesCommand) {
                const [uri, position, references] = args;
                context.showReferences({
                    textDocument: { uri },
                    position,
                    references,
                });
            }
        },
    };
    function worker(uri, callback) {
        const virtualFile = options.documents.getVirtualFileByUri(uri);
        if (!(virtualFile instanceof vue_language_core_1.VueFile))
            return;
        return callback(virtualFile);
    }
}
exports.default = default_1;
//# sourceMappingURL=vue-codelens-references.js.map
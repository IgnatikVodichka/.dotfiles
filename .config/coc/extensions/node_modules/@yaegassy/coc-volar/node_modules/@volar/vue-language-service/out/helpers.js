Object.defineProperty(exports, "__esModule", { value: true });
exports.getTemplateTagsAndAttrs = exports.getElementAttrs = exports.checkComponentNames = exports.checkEventsOfTag = exports.checkPropsOfTag = void 0;
const vue = require("@volar/vue-language-core");
const embedded = require("@volar/language-core");
const reactivity_1 = require("@vue/reactivity");
const localTypes_1 = require("@volar/vue-language-core/out/utils/localTypes");
const shared_1 = require("@vue/shared");
function checkPropsOfTag(ts, tsLs, sourceFile, tag) {
    var _a, _b;
    const checker = tsLs.getProgram().getTypeChecker();
    const components = getComponentsType(ts, tsLs, sourceFile);
    if (!components)
        return [];
    const links = tag.split('.');
    let componentSymbol = (_b = (_a = components.componentsType.getProperty(links[0])) !== null && _a !== void 0 ? _a : components.componentsType.getProperty((0, shared_1.camelize)(links[0]))) !== null && _b !== void 0 ? _b : components.componentsType.getProperty((0, shared_1.capitalize)((0, shared_1.camelize)(links[0])));
    if (!componentSymbol)
        return [];
    let componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.componentsNode);
    for (let i = 1; i < links.length; i++) {
        componentSymbol = componentType.getProperty(links[i]);
        if (componentSymbol) {
            componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.componentsNode);
        }
        else {
            return [];
        }
    }
    const result = new Set();
    for (const sig of componentType.getCallSignatures()) {
        const propParam = sig.parameters[0];
        if (propParam) {
            const propsType = checker.getTypeOfSymbolAtLocation(propParam, components.componentsNode);
            const props = propsType.getProperties();
            for (const prop of props) {
                result.add(prop.name);
            }
        }
    }
    for (const sig of componentType.getConstructSignatures()) {
        const instanceType = sig.getReturnType();
        const propsSymbol = instanceType.getProperty('$props');
        if (propsSymbol) {
            const propsType = checker.getTypeOfSymbolAtLocation(propsSymbol, components.componentsNode);
            const props = propsType.getProperties();
            for (const prop of props) {
                result.add(prop.name);
            }
        }
    }
    return [...result];
}
exports.checkPropsOfTag = checkPropsOfTag;
function checkEventsOfTag(ts, tsLs, sourceFile, tag) {
    var _a, _b;
    const checker = tsLs.getProgram().getTypeChecker();
    const components = getComponentsType(ts, tsLs, sourceFile);
    if (!components)
        return [];
    const links = tag.split('.');
    let componentSymbol = (_b = (_a = components.componentsType.getProperty(links[0])) !== null && _a !== void 0 ? _a : components.componentsType.getProperty((0, shared_1.camelize)(links[0]))) !== null && _b !== void 0 ? _b : components.componentsType.getProperty((0, shared_1.capitalize)((0, shared_1.camelize)(links[0])));
    if (!componentSymbol)
        return [];
    let componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.componentsNode);
    for (let i = 1; i < links.length; i++) {
        componentSymbol = componentType.getProperty(links[i]);
        if (componentSymbol) {
            componentType = checker.getTypeOfSymbolAtLocation(componentSymbol, components.componentsNode);
        }
        else {
            return [];
        }
    }
    const result = new Set();
    // for (const sig of componentType.getCallSignatures()) {
    // 	const emitParam = sig.parameters[1];
    // 	if (emitParam) {
    // 		// TODO
    // 	}
    // }
    for (const sig of componentType.getConstructSignatures()) {
        const instanceType = sig.getReturnType();
        const emitSymbol = instanceType.getProperty('$emit');
        if (emitSymbol) {
            const emitType = checker.getTypeOfSymbolAtLocation(emitSymbol, components.componentsNode);
            for (const call of emitType.getCallSignatures()) {
                const eventNameParamSymbol = call.parameters[0];
                if (eventNameParamSymbol) {
                    const eventNameParamType = checker.getTypeOfSymbolAtLocation(eventNameParamSymbol, components.componentsNode);
                    if (eventNameParamType.isStringLiteral()) {
                        result.add(eventNameParamType.value);
                    }
                }
            }
        }
    }
    return [...result];
}
exports.checkEventsOfTag = checkEventsOfTag;
function checkComponentNames(ts, tsLs, sourceFile) {
    var _a, _b, _c;
    return (_c = (_b = (_a = getComponentsType(ts, tsLs, sourceFile)) === null || _a === void 0 ? void 0 : _a.componentsType) === null || _b === void 0 ? void 0 : _b.getProperties().map(c => c.name).filter(entry => entry.indexOf('$') === -1 && !entry.startsWith('_'))) !== null && _c !== void 0 ? _c : [];
}
exports.checkComponentNames = checkComponentNames;
function getElementAttrs(ts, tsLs, fileName, tagName) {
    var _a, _b;
    const sharedTypesFileName = fileName.substring(0, fileName.lastIndexOf('/')) + '/' + localTypes_1.typesFileName;
    let tsSourceFile;
    if (tsSourceFile = (_a = tsLs.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(sharedTypesFileName)) {
        const typeNode = tsSourceFile.statements.find((node) => ts.isTypeAliasDeclaration(node) && node.name.getText() === 'IntrinsicElements');
        const checker = (_b = tsLs.getProgram()) === null || _b === void 0 ? void 0 : _b.getTypeChecker();
        if (checker && typeNode) {
            const type = checker.getTypeFromTypeNode(typeNode.type);
            const el = type.getProperty(tagName);
            if (el) {
                const attrs = checker.getTypeOfSymbolAtLocation(el, typeNode).getProperties();
                return attrs.map(c => c.name);
            }
        }
    }
    return [];
}
exports.getElementAttrs = getElementAttrs;
function getComponentsType(ts, tsLs, sourceFile) {
    var _a, _b;
    if (!(sourceFile instanceof vue.VueFile)) {
        return;
    }
    let file;
    let tsSourceFile;
    embedded.forEachEmbeddedFile(sourceFile, embedded => {
        if (embedded.fileName === sourceFile.mainScriptName) {
            file = embedded;
        }
    });
    if (file && (tsSourceFile = (_a = tsLs.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(file.fileName))) {
        const componentsNode = getComponentsNode(ts, tsSourceFile);
        const checker = (_b = tsLs.getProgram()) === null || _b === void 0 ? void 0 : _b.getTypeChecker();
        if (checker && componentsNode) {
            return {
                componentsNode,
                componentsType: checker.getTypeAtLocation(componentsNode),
            };
        }
    }
    function getComponentsNode(ts, sourceFile) {
        let componentsNode;
        walk(sourceFile);
        return componentsNode;
        function walk(node) {
            if (componentsNode) {
                return;
            }
            else if (ts.isVariableDeclaration(node) && node.name.getText() === '__VLS_components') {
                componentsNode = node;
            }
            else {
                node.forEachChild(walk);
            }
        }
    }
}
const map = new WeakMap();
function getTemplateTagsAndAttrs(sourceFile) {
    var _a;
    if (!map.has(sourceFile)) {
        const getter = (0, reactivity_1.computed)(() => {
            var _a;
            if (!(sourceFile instanceof vue.VueFile))
                return;
            const ast = (_a = sourceFile.compiledSFCTemplate) === null || _a === void 0 ? void 0 : _a.ast;
            const tags = new Map();
            if (ast) {
                vue.walkElementNodes(ast, node => {
                    var _a;
                    if (!tags.has(node.tag)) {
                        tags.set(node.tag, { offsets: [], attrs: new Map() });
                    }
                    const tag = tags.get(node.tag);
                    const startTagHtmlOffset = node.loc.start.offset + node.loc.source.indexOf(node.tag);
                    const endTagHtmlOffset = node.loc.start.offset + node.loc.source.lastIndexOf(node.tag);
                    tag.offsets.push(startTagHtmlOffset);
                    if (!node.isSelfClosing) {
                        tag.offsets.push(endTagHtmlOffset);
                    }
                    for (const prop of node.props) {
                        let name;
                        let offset;
                        if (prop.type === 7 /* CompilerDOM.NodeTypes.DIRECTIVE */
                            && ((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* CompilerDOM.NodeTypes.SIMPLE_EXPRESSION */
                            && prop.arg.isStatic) {
                            name = prop.arg.content;
                            offset = prop.arg.loc.start.offset;
                        }
                        else if (prop.type === 6 /* CompilerDOM.NodeTypes.ATTRIBUTE */) {
                            name = prop.name;
                            offset = prop.loc.start.offset;
                        }
                        if (name !== undefined && offset !== undefined) {
                            if (!tag.attrs.has(name)) {
                                tag.attrs.set(name, { offsets: [] });
                            }
                            tag.attrs.get(name).offsets.push(offset);
                        }
                    }
                });
            }
            return tags;
        });
        map.set(sourceFile, getter);
    }
    return (_a = map.get(sourceFile).value) !== null && _a !== void 0 ? _a : new Map();
}
exports.getTemplateTagsAndAttrs = getTemplateTagsAndAttrs;
//# sourceMappingURL=helpers.js.map
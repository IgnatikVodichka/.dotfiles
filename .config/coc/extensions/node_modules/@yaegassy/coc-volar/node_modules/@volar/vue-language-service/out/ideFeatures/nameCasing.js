var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detect = exports.convertAttrName = exports.convertTagName = void 0;
const shared_1 = require("@vue/shared");
const helpers_1 = require("../helpers");
const vue = require("@volar/vue-language-core");
const vscode = require("vscode-languageserver-protocol");
const types_1 = require("../types");
function convertTagName(context, uri, casing) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootFile = context.documents.getRootFileBySourceFileUri(uri);
        if (!(rootFile instanceof vue.VueFile))
            return;
        const desc = rootFile.sfc;
        if (!desc.template)
            return;
        const template = desc.template;
        const document = context.documents.getDocumentByFileName(rootFile.snapshot, rootFile.fileName);
        const edits = [];
        const components = (0, helpers_1.checkComponentNames)(context.host.getTypeScriptModule(), context.typescriptLanguageService, rootFile);
        const tags = (0, helpers_1.getTemplateTagsAndAttrs)(rootFile);
        for (const [tagName, { offsets }] of tags) {
            const componentName = components.find(component => component === tagName || (0, shared_1.hyphenate)(component) === tagName);
            if (componentName) {
                for (const offset of offsets) {
                    const start = document.positionAt(template.startTagEnd + offset);
                    const end = document.positionAt(template.startTagEnd + offset + tagName.length);
                    const range = vscode.Range.create(start, end);
                    if (casing === types_1.TagNameCasing.Kebab && tagName !== (0, shared_1.hyphenate)(componentName)) {
                        edits.push(vscode.TextEdit.replace(range, (0, shared_1.hyphenate)(componentName)));
                    }
                    if (casing === types_1.TagNameCasing.Pascal && tagName !== componentName) {
                        edits.push(vscode.TextEdit.replace(range, componentName));
                    }
                }
            }
        }
        return edits;
    });
}
exports.convertTagName = convertTagName;
function convertAttrName(context, uri, casing) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootFile = context.documents.getRootFileBySourceFileUri(uri);
        if (!(rootFile instanceof vue.VueFile))
            return;
        const desc = rootFile.sfc;
        if (!desc.template)
            return;
        const template = desc.template;
        const document = context.documents.getDocumentByFileName(rootFile.snapshot, rootFile.fileName);
        const edits = [];
        const components = (0, helpers_1.checkComponentNames)(context.host.getTypeScriptModule(), context.typescriptLanguageService, rootFile);
        const tags = (0, helpers_1.getTemplateTagsAndAttrs)(rootFile);
        for (const [tagName, { attrs }] of tags) {
            const componentName = components.find(component => component === tagName || (0, shared_1.hyphenate)(component) === tagName);
            if (componentName) {
                const props = (0, helpers_1.checkPropsOfTag)(context.host.getTypeScriptModule(), context.typescriptLanguageService, rootFile, componentName);
                for (const [attrName, { offsets }] of attrs) {
                    const propName = props.find(prop => prop === attrName || (0, shared_1.hyphenate)(prop) === attrName);
                    if (propName) {
                        for (const offset of offsets) {
                            const start = document.positionAt(template.startTagEnd + offset);
                            const end = document.positionAt(template.startTagEnd + offset + attrName.length);
                            const range = vscode.Range.create(start, end);
                            if (casing === types_1.AttrNameCasing.Kebab && attrName !== (0, shared_1.hyphenate)(propName)) {
                                edits.push(vscode.TextEdit.replace(range, (0, shared_1.hyphenate)(propName)));
                            }
                            if (casing === types_1.AttrNameCasing.Camel && attrName !== propName) {
                                edits.push(vscode.TextEdit.replace(range, propName));
                            }
                        }
                    }
                }
            }
        }
        return edits;
    });
}
exports.convertAttrName = convertAttrName;
function detect(context, uri) {
    const rootFile = context.documents.getRootFileBySourceFileUri(uri);
    if (!(rootFile instanceof vue.VueFile)) {
        return {
            tag: [],
            attr: [],
        };
    }
    return {
        tag: getTagNameCase(rootFile),
        attr: getAttrNameCase(rootFile),
    };
    function getAttrNameCase(file) {
        const tags = (0, helpers_1.getTemplateTagsAndAttrs)(file);
        const result = [];
        for (const [_, { attrs }] of tags) {
            for (const [tagName] of attrs) {
                // attrName
                if (tagName !== (0, shared_1.hyphenate)(tagName)) {
                    result.push(types_1.AttrNameCasing.Camel);
                    break;
                }
            }
            for (const [tagName] of attrs) {
                // attr-name
                if (tagName.indexOf('-') >= 0) {
                    result.push(types_1.AttrNameCasing.Kebab);
                    break;
                }
            }
        }
        return result;
    }
    function getTagNameCase(file) {
        const components = (0, helpers_1.checkComponentNames)(context.host.getTypeScriptModule(), context.typescriptLanguageService, file);
        const tagNames = (0, helpers_1.getTemplateTagsAndAttrs)(file);
        const result = [];
        let anyComponentUsed = false;
        for (const component of components) {
            if (tagNames.has(component) || tagNames.has((0, shared_1.hyphenate)(component))) {
                anyComponentUsed = true;
                break;
            }
        }
        if (!anyComponentUsed) {
            return []; // not sure component style, because do not have any component using in <template> for check
        }
        for (const [tagName] of tagNames) {
            // TagName
            if (tagName !== (0, shared_1.hyphenate)(tagName)) {
                result.push(types_1.TagNameCasing.Pascal);
                break;
            }
        }
        for (const component of components) {
            // Tagname -> tagname
            // TagName -> tag-name
            if (component !== (0, shared_1.hyphenate)(component) && tagNames.has((0, shared_1.hyphenate)(component))) {
                result.push(types_1.TagNameCasing.Kebab);
                break;
            }
        }
        return result;
    }
}
exports.detect = detect;
//# sourceMappingURL=nameCasing.js.map
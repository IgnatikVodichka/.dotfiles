Object.defineProperty(exports, "__esModule", { value: true });
exports.createDocumentService = exports.isTsDocument = exports.createDocumentServiceContext = void 0;
const language_core_1 = require("@volar/language-core");
const shared = require("@volar/shared");
const autoInsert = require("./documentFeatures/autoInsert");
const colorPresentations = require("./documentFeatures/colorPresentations");
const documentColors = require("./documentFeatures/documentColors");
const documentSymbols = require("./documentFeatures/documentSymbols");
const foldingRanges = require("./documentFeatures/foldingRanges");
const format = require("./documentFeatures/format");
const linkedEditingRanges = require("./documentFeatures/linkedEditingRanges");
const selectionRanges = require("./documentFeatures/selectionRanges");
const documents_1 = require("./documents");
const singleFileTypeScriptService_1 = require("./utils/singleFileTypeScriptService");
function createDocumentServiceContext(options) {
    let plugins;
    const ts = options.ts;
    const pluginContext = {
        typescript: {
            module: ts,
            languageServiceHost: singleFileTypeScriptService_1.singleFileTypeScriptServiceHost,
            languageService: ts.createLanguageService(singleFileTypeScriptService_1.singleFileTypeScriptServiceHost),
        },
        env: options.env,
    };
    const languageModules = options.getLanguageModules();
    const lastUpdateVersions = new Map();
    const virtualFiles = (0, language_core_1.createVirtualFiles)(languageModules);
    const textDocumentMapper = (0, documents_1.createDocumentsAndSourceMaps)(virtualFiles);
    const context = {
        typescript: ts,
        get plugins() {
            var _a;
            if (!plugins) {
                plugins = options.getPlugins();
                for (const plugin of plugins) {
                    (_a = plugin.setup) === null || _a === void 0 ? void 0 : _a.call(plugin, pluginContext);
                }
            }
            return plugins;
        },
        pluginContext,
        documents: textDocumentMapper,
        update(document) {
            let lastVersion = lastUpdateVersions.get(document.uri);
            if (lastVersion === undefined || lastVersion !== document.version) {
                const fileName = shared.getPathOfUri(document.uri);
                virtualFiles.update(fileName, ts.ScriptSnapshot.fromString(document.getText()));
                lastUpdateVersions.set(document.uri, document.version);
            }
        },
        updateVirtualFile(fileName, snapshot) {
            virtualFiles.update(fileName, snapshot);
        },
        prepareLanguageServices(document) {
            if (isTsDocument(document)) {
                (0, singleFileTypeScriptService_1.updateSingleFileTypeScriptServiceHost)(ts, document);
            }
        },
    };
    return context;
}
exports.createDocumentServiceContext = createDocumentServiceContext;
function isTsDocument(document) {
    return document.languageId === 'javascript' ||
        document.languageId === 'typescript' ||
        document.languageId === 'javascriptreact' ||
        document.languageId === 'typescriptreact';
}
exports.isTsDocument = isTsDocument;
function createDocumentService(context) {
    return {
        format: format.register(context),
        getFoldingRanges: foldingRanges.register(context),
        getSelectionRanges: selectionRanges.register(context),
        findLinkedEditingRanges: linkedEditingRanges.register(context),
        findDocumentSymbols: documentSymbols.register(context),
        findDocumentColors: documentColors.register(context),
        getColorPresentations: colorPresentations.register(context),
        doAutoInsert: autoInsert.register(context),
        context,
    };
}
exports.createDocumentService = createDocumentService;
//# sourceMappingURL=baseDocumentService.js.map
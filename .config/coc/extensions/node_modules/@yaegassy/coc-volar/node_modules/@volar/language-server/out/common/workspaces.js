var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkspaces = void 0;
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver");
const types_1 = require("../types");
const workspace_1 = require("./workspace");
function createWorkspaces(context) {
    var _a, _b;
    const workspaces = new Map();
    let semanticTokensReq = 0;
    let documentUpdatedReq = 0;
    context.documents.onDidChangeContent(({ textDocument }) => {
        updateDiagnostics(textDocument.uri);
    });
    context.documents.onDidClose(({ textDocument }) => {
        context.server.connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: [] });
    });
    context.fileSystemHost.onDidChangeWatchedFiles(({ changes }) => {
        const tsConfigChanges = changes.filter(change => workspace_1.rootTsConfigNames.includes(change.uri.substring(change.uri.lastIndexOf('/') + 1)));
        if (tsConfigChanges.length) {
            reloadDiagnostics();
        }
        else {
            updateDiagnosticsAndSemanticTokens();
        }
    });
    (_b = (_a = context.server.runtimeEnv).onDidChangeConfiguration) === null || _b === void 0 ? void 0 : _b.call(_a, () => __awaiter(this, void 0, void 0, function* () {
        updateDiagnosticsAndSemanticTokens();
    }));
    return {
        workspaces,
        getProject: getProjectAndTsConfig,
        reloadProject,
        add: (rootUri) => {
            if (!workspaces.has(rootUri.toString())) {
                workspaces.set(rootUri.toString(), (0, workspace_1.createWorkspace)({
                    workspaces: context,
                    rootUri,
                }));
            }
        },
        remove: (rootUri) => {
            const _workspace = workspaces.get(rootUri.toString());
            workspaces.delete(rootUri.toString());
            (() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                (_a = (yield _workspace)) === null || _a === void 0 ? void 0 : _a.dispose();
            }))();
        },
    };
    function reloadProject() {
        return __awaiter(this, void 0, void 0, function* () {
            context.fileSystemHost.reload();
            for (const [_, workspace] of workspaces) {
                (yield workspace).reload();
            }
            reloadDiagnostics();
        });
    }
    function reloadDiagnostics() {
        for (const doc of context.documents.data.values()) {
            context.server.connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
        }
        updateDiagnosticsAndSemanticTokens();
    }
    function updateDiagnosticsAndSemanticTokens() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const req = ++semanticTokensReq;
            yield updateDiagnostics();
            const delay = (_b = yield ((_a = context.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('volar.diagnostics.delay'))) !== null && _b !== void 0 ? _b : 200;
            yield shared.sleep(delay);
            if (req === semanticTokensReq) {
                if ((_c = context.initParams.capabilities.textDocument) === null || _c === void 0 ? void 0 : _c.semanticTokens) {
                    context.server.connection.languages.semanticTokens.refresh();
                }
                if ((_d = context.initParams.capabilities.textDocument) === null || _d === void 0 ? void 0 : _d.inlayHint) {
                    context.server.connection.languages.inlayHint.refresh();
                }
            }
        });
    }
    function updateDiagnostics(docUri) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = context.initOptions.diagnosticModel) !== null && _a !== void 0 ? _a : types_1.DiagnosticModel.Push) !== types_1.DiagnosticModel.Push)
                return;
            const req = ++documentUpdatedReq;
            const delay = (_c = yield ((_b = context.configurationHost) === null || _b === void 0 ? void 0 : _b.getConfiguration('volar.diagnostics.delay'))) !== null && _c !== void 0 ? _c : 200;
            const cancel = context.cancelTokenHost.createCancellationToken({
                get isCancellationRequested() {
                    return req !== documentUpdatedReq;
                },
                onCancellationRequested: vscode.Event.None,
            });
            const changeDoc = docUri ? context.documents.data.uriGet(docUri) : undefined;
            const otherDocs = [...context.documents.data.values()].filter(doc => doc !== changeDoc);
            if (changeDoc) {
                yield shared.sleep(delay);
                if (cancel.isCancellationRequested) {
                    return;
                }
                yield sendDocumentDiagnostics(changeDoc.uri, changeDoc.version, cancel);
            }
            for (const doc of otherDocs) {
                yield shared.sleep(delay);
                if (cancel.isCancellationRequested) {
                    break;
                }
                yield sendDocumentDiagnostics(doc.uri, doc.version, cancel);
            }
        });
    }
    function sendDocumentDiagnostics(uri, version, cancel) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const project = (_a = (yield getProjectAndTsConfig(uri))) === null || _a === void 0 ? void 0 : _a.project;
            if (!project)
                return;
            const languageService = project.getLanguageService();
            const errors = yield languageService.doValidation(uri, cancel, result => {
                context.server.connection.sendDiagnostics({ uri: uri, diagnostics: result.map(addVersion), version });
            });
            context.server.connection.sendDiagnostics({ uri: uri, diagnostics: errors.map(addVersion), version });
            function addVersion(error) {
                if (error.data === undefined) {
                    error.data = { version };
                }
                else if (typeof error.data === 'object') {
                    error.data.version = version;
                }
                return error;
            }
        });
    }
    function getProjectAndTsConfig(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const rootUris = [...workspaces.keys()]
                .filter(rootUri => shared.isFileInDir(shared.getPathOfUri(uri), shared.getPathOfUri(rootUri)))
                .sort((a, b) => (0, workspace_1.sortTsConfigs)(shared.getPathOfUri(uri), shared.getPathOfUri(a), shared.getPathOfUri(b)));
            for (const rootUri of rootUris) {
                const workspace = yield workspaces.get(rootUri);
                const projectAndTsConfig = yield (workspace === null || workspace === void 0 ? void 0 : workspace.getProjectAndTsConfig(uri));
                if (projectAndTsConfig) {
                    return projectAndTsConfig;
                }
            }
            if (rootUris.length) {
                const project = yield ((_a = (yield workspaces.get(rootUris[0]))) === null || _a === void 0 ? void 0 : _a.getInferredProject());
                project === null || project === void 0 ? void 0 : project.tryAddFile(shared.getPathOfUri(uri));
                return {
                    tsconfig: undefined,
                    project,
                };
            }
        });
    }
}
exports.createWorkspaces = createWorkspaces;
//# sourceMappingURL=workspaces.js.map
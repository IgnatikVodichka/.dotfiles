var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProject = void 0;
const embedded = require("@volar/language-core");
const embeddedLS = require("@volar/language-service");
const shared = require("@volar/shared");
const path = require("typesafe-path");
const vscode = require("vscode-languageserver");
const uriMap_1 = require("./utils/uriMap");
function createProject(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const sys = context.workspace.workspaces.fileSystemHost.getWorkspaceFileSystem(context.rootUri);
        let typeRootVersion = 0;
        let projectVersion = 0;
        let projectVersionUpdateTime = context.workspace.workspaces.cancelTokenHost.getMtime();
        let languageService;
        let parsedCommandLine = createParsedCommandLine(context.workspace.workspaces.ts, sys, shared.getPathOfUri(context.rootUri.toString()), context.tsConfig, context.workspace.workspaces.plugins);
        const scripts = (0, uriMap_1.createUriMap)();
        const languageServiceHost = createLanguageServiceHost();
        const disposeWatchEvent = context.workspace.workspaces.fileSystemHost.onDidChangeWatchedFiles(params => {
            onWorkspaceFilesChanged(params.changes);
        });
        const disposeDocChange = context.workspace.workspaces.documents.onDidChangeContent(() => {
            projectVersion++;
            projectVersionUpdateTime = context.workspace.workspaces.cancelTokenHost.getMtime();
        });
        return {
            tsConfig: context.tsConfig,
            scripts,
            languageServiceHost,
            getLanguageService,
            getLanguageServiceDontCreate: () => languageService,
            getParsedCommandLine: () => parsedCommandLine,
            tryAddFile: (fileName) => {
                if (!parsedCommandLine.fileNames.includes(fileName)) {
                    parsedCommandLine.fileNames.push(fileName);
                    projectVersion++;
                    projectVersionUpdateTime = context.workspace.workspaces.cancelTokenHost.getMtime();
                }
            },
            dispose,
        };
        function getLanguageService() {
            if (!languageService) {
                const languageModules = context.workspace.workspaces.plugins.map(plugin => { var _a, _b, _c; return (_c = (_b = (_a = plugin.semanticService) === null || _a === void 0 ? void 0 : _a.getLanguageModules) === null || _b === void 0 ? void 0 : _b.call(_a, languageServiceHost)) !== null && _c !== void 0 ? _c : []; }).flat();
                const languageContext = embedded.createLanguageContext(languageServiceHost, languageModules);
                const languageServiceContext = embeddedLS.createLanguageServiceContext({
                    host: languageServiceHost,
                    context: languageContext,
                    getPlugins() {
                        var _a, _b;
                        return [
                            ...(_b = (_a = context.serverConfig) === null || _a === void 0 ? void 0 : _a.plugins) !== null && _b !== void 0 ? _b : [],
                            ...context.workspace.workspaces.plugins.map(plugin => { var _a, _b, _c; return (_c = (_b = (_a = plugin.semanticService) === null || _a === void 0 ? void 0 : _a.getServicePlugins) === null || _b === void 0 ? void 0 : _b.call(_a, languageServiceHost, languageService)) !== null && _c !== void 0 ? _c : []; }).flat(),
                        ];
                    },
                    env: {
                        rootUri: context.rootUri,
                        configurationHost: context.workspace.workspaces.configurationHost,
                        fileSystemProvider: context.workspace.workspaces.server.runtimeEnv.fileSystemProvide,
                        documentContext: getHTMLDocumentContext(context.workspace.workspaces.ts, languageServiceHost),
                        schemaRequestService: (uri) => __awaiter(this, void 0, void 0, function* () {
                            const protocol = uri.substring(0, uri.indexOf(':'));
                            const builtInHandler = context.workspace.workspaces.server.runtimeEnv.schemaRequestHandlers[protocol];
                            if (builtInHandler) {
                                return yield builtInHandler(uri);
                            }
                            return '';
                        }),
                    },
                    documentRegistry: context.documentRegistry,
                });
                languageService = embeddedLS.createLanguageService(languageServiceContext);
            }
            return languageService;
        }
        function onWorkspaceFilesChanged(changes) {
            return __awaiter(this, void 0, void 0, function* () {
                const _projectVersion = projectVersion;
                for (const change of changes) {
                    const script = scripts.uriGet(change.uri);
                    if (script && (change.type === vscode.FileChangeType.Changed || change.type === vscode.FileChangeType.Created)) {
                        if (script.version >= 0) {
                            script.version = -1;
                        }
                        else {
                            script.version--;
                        }
                    }
                    else if (script && change.type === vscode.FileChangeType.Deleted) {
                        scripts.uriDelete(change.uri);
                    }
                    if (script) {
                        projectVersion++;
                    }
                }
                const creates = changes.filter(change => change.type === vscode.FileChangeType.Created);
                const deletes = changes.filter(change => change.type === vscode.FileChangeType.Deleted);
                if (creates.length || deletes.length) {
                    parsedCommandLine = createParsedCommandLine(context.workspace.workspaces.ts, sys, shared.getPathOfUri(context.rootUri.toString()), context.tsConfig, context.workspace.workspaces.plugins);
                    projectVersion++;
                    typeRootVersion++;
                }
                if (_projectVersion !== projectVersion) {
                    projectVersionUpdateTime = context.workspace.workspaces.cancelTokenHost.getMtime();
                }
            });
        }
        function createLanguageServiceHost() {
            var _a;
            const token = {
                isCancellationRequested() {
                    return context.workspace.workspaces.cancelTokenHost.getMtime() !== projectVersionUpdateTime;
                },
                throwIfCancellationRequested() { },
            };
            let host = {
                // ts
                getNewLine: () => sys.newLine,
                useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,
                readFile: sys.readFile,
                writeFile: sys.writeFile,
                directoryExists: sys.directoryExists,
                getDirectories: sys.getDirectories,
                readDirectory: sys.readDirectory,
                realpath: sys.realpath,
                fileExists: sys.fileExists,
                getCurrentDirectory: () => shared.getPathOfUri(context.rootUri.toString()),
                getProjectReferences: () => parsedCommandLine.projectReferences,
                getCancellationToken: () => token,
                // custom
                getDefaultLibFileName: options => {
                    try {
                        return context.workspace.workspaces.ts.getDefaultLibFilePath(options);
                    }
                    catch (_a) {
                        // web
                        return context.workspace.workspaces.initOptions.typescript.tsdk + '/' + context.workspace.workspaces.ts.getDefaultLibFileName(options);
                    }
                },
                getProjectVersion: () => projectVersion.toString(),
                getTypeRootsVersion: () => typeRootVersion,
                getScriptFileNames: () => parsedCommandLine.fileNames,
                getCompilationSettings: () => parsedCommandLine.options,
                getScriptVersion,
                getScriptSnapshot,
                getTypeScriptModule: () => context.workspace.workspaces.ts,
            };
            if (context.workspace.workspaces.initOptions.noProjectReferences) {
                host.getProjectReferences = undefined;
                host.getCompilationSettings = () => (Object.assign(Object.assign({}, parsedCommandLine.options), { rootDir: undefined, composite: false }));
            }
            if (context.workspace.workspaces.tsLocalized) {
                host.getLocalizedDiagnosticMessages = () => context.workspace.workspaces.tsLocalized;
            }
            for (const plugin of context.workspace.workspaces.plugins) {
                if ((_a = plugin.semanticService) === null || _a === void 0 ? void 0 : _a.resolveLanguageServiceHost) {
                    host = plugin.semanticService.resolveLanguageServiceHost(context.workspace.workspaces.ts, sys, context.tsConfig, host);
                }
            }
            return host;
            function getScriptVersion(fileName) {
                var _a, _b;
                const doc = context.workspace.workspaces.documents.data.pathGet(fileName);
                if (doc) {
                    return doc.version.toString();
                }
                return (_b = (_a = scripts.pathGet(fileName)) === null || _a === void 0 ? void 0 : _a.version.toString()) !== null && _b !== void 0 ? _b : '';
            }
            function getScriptSnapshot(fileName) {
                var _a;
                const doc = context.workspace.workspaces.documents.data.pathGet(fileName);
                if (doc) {
                    return doc.getSnapshot();
                }
                const script = scripts.pathGet(fileName);
                if (script && script.snapshotVersion === script.version) {
                    return script.snapshot;
                }
                if (sys.fileExists(fileName)) {
                    if (context.workspace.workspaces.initOptions.maxFileSize) {
                        const fileSize = (_a = sys.getFileSize) === null || _a === void 0 ? void 0 : _a.call(sys, fileName);
                        if (fileSize !== undefined && fileSize > context.workspace.workspaces.initOptions.maxFileSize) {
                            console.warn(`IGNORING "${fileName}" because it is too large (${fileSize}bytes > ${context.workspace.workspaces.initOptions.maxFileSize}bytes)`);
                            return context.workspace.workspaces.ts.ScriptSnapshot.fromString('');
                        }
                    }
                    const text = sys.readFile(fileName, 'utf8');
                    if (text !== undefined) {
                        const snapshot = context.workspace.workspaces.ts.ScriptSnapshot.fromString(text);
                        if (script) {
                            script.snapshot = snapshot;
                            script.snapshotVersion = script.version;
                        }
                        else {
                            scripts.pathSet(fileName, {
                                version: -1,
                                fileName: fileName,
                                snapshot: snapshot,
                                snapshotVersion: -1,
                            });
                        }
                        return snapshot;
                    }
                }
            }
        }
        function dispose() {
            languageService === null || languageService === void 0 ? void 0 : languageService.dispose();
            scripts.clear();
            disposeWatchEvent();
            disposeDocChange();
        }
    });
}
exports.createProject = createProject;
function createParsedCommandLine(ts, sys, rootPath, tsConfig, plugins) {
    const extraFileExtensions = plugins.map(plugin => plugin.extraFileExtensions).flat();
    try {
        let content;
        if (typeof tsConfig === 'string') {
            const config = ts.readJsonConfigFile(tsConfig, sys.readFile);
            content = ts.parseJsonSourceFileConfigFileContent(config, sys, path.dirname(tsConfig), {}, tsConfig, undefined, extraFileExtensions);
        }
        else {
            content = ts.parseJsonConfigFileContent({ files: [] }, sys, rootPath, tsConfig, path.join(rootPath, 'jsconfig.json'), undefined, extraFileExtensions);
        }
        // fix https://github.com/johnsoncodehk/volar/issues/1786
        // https://github.com/microsoft/TypeScript/issues/30457
        // patching ts server broke with outDir + rootDir + composite/incremental
        content.options.outDir = undefined;
        content.fileNames = content.fileNames.map(shared.normalizeFileName);
        return content;
    }
    catch (_a) {
        // will be failed if web fs host first result not ready
        return {
            errors: [],
            fileNames: [],
            options: {},
        };
    }
}
function getHTMLDocumentContext(ts, host) {
    const documentContext = {
        resolveReference(ref, base) {
            var _a, _b;
            const isUri = base.indexOf('://') >= 0;
            const resolveResult = ts.resolveModuleName(ref, isUri ? shared.getPathOfUri(base) : base, host.getCompilationSettings(), host);
            const failedLookupLocations = resolveResult.failedLookupLocations;
            const dirs = new Set();
            for (let failed of failedLookupLocations) {
                const fileName = path.basename(failed);
                if (fileName === 'index.d.ts' || fileName === '*.d.ts') {
                    dirs.add(path.dirname(failed));
                }
                if (failed.endsWith('.d.ts')) {
                    failed = failed.substring(0, failed.length - '.d.ts'.length);
                }
                else {
                    continue;
                }
                if (host.fileExists(failed)) {
                    return isUri ? shared.getUriByPath(failed) : failed;
                }
            }
            for (const dir of dirs) {
                if ((_b = (_a = host.directoryExists) === null || _a === void 0 ? void 0 : _a.call(host, dir)) !== null && _b !== void 0 ? _b : true) {
                    return isUri ? shared.getUriByPath(dir) : dir;
                }
            }
            return undefined;
        },
    };
    return documentContext;
}
//# sourceMappingURL=project.js.map
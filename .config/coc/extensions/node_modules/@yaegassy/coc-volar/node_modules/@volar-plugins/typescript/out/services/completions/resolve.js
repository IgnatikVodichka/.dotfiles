var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLineText = exports.register = void 0;
const vscode = require("vscode-languageserver-protocol");
const transforms_1 = require("../../utils/transforms");
const basic_1 = require("./basic");
const previewer = require("../../utils/previewer");
const shared = require("@volar/shared");
const getFormatCodeSettings_1 = require("../../configs/getFormatCodeSettings");
const getUserPreferences_1 = require("../../configs/getUserPreferences");
const snippetForFunctionCall_1 = require("../../utils/snippetForFunctionCall");
const shared_1 = require("../../configs/shared");
function register(rootUri, languageService, getTextDocument, getConfiguration) {
    return (item, newPosition) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const data = item.data;
        if (!data)
            return item;
        const fileName = data.fileName;
        let offset = data.offset;
        const document = getTextDocument(data.uri);
        if (newPosition && document) {
            offset = document.offsetAt(newPosition);
        }
        const [formatOptions, preferences] = document ? yield Promise.all([
            (0, getFormatCodeSettings_1.getFormatCodeSettings)(getConfiguration, document.uri),
            (0, getUserPreferences_1.getUserPreferences)(getConfiguration, document.uri, rootUri),
        ]) : [{}, {}];
        let details;
        try {
            details = languageService.getCompletionEntryDetails(fileName, offset, data.originalItem.name, formatOptions, data.originalItem.source, preferences, data.originalItem.data);
        }
        catch (err) {
            item.detail = `[TS Error]\n${err}\n${JSON.stringify(err, undefined, 2)}`;
        }
        if (!details)
            return item;
        const detailTexts = [];
        if (details.codeActions) {
            if (!item.additionalTextEdits)
                item.additionalTextEdits = [];
            for (const action of details.codeActions) {
                detailTexts.push(action.description);
                for (const changes of action.changes) {
                    const entries = changes.textChanges.map(textChange => {
                        return { fileName, textSpan: textChange.span };
                    });
                    const locs = (0, transforms_1.entriesToLocations)(entries, getTextDocument);
                    locs.forEach((loc, index) => {
                        var _a;
                        (_a = item.additionalTextEdits) === null || _a === void 0 ? void 0 : _a.push(vscode.TextEdit.replace(loc.range, changes.textChanges[index].newText));
                    });
                }
            }
        }
        if (details.displayParts) {
            detailTexts.push(previewer.plainWithLinks(details.displayParts, { toResource }, getTextDocument));
        }
        if (detailTexts.length) {
            item.detail = detailTexts.join('\n');
        }
        item.documentation = {
            kind: 'markdown',
            value: previewer.markdownDocumentation(details.documentation, details.tags, { toResource }, getTextDocument),
        };
        if (details) {
            (0, basic_1.handleKindModifiers)(item, details);
        }
        if (document) {
            const useCodeSnippetsOnMethodSuggest = (_a = yield getConfiguration(((0, shared_1.isTypeScriptDocument)(document.uri) ? 'typescript' : 'javascript') + '.suggest.completeFunctionCalls')) !== null && _a !== void 0 ? _a : false;
            const useCodeSnippet = useCodeSnippetsOnMethodSuggest && (item.kind === vscode.CompletionItemKind.Function || item.kind === vscode.CompletionItemKind.Method);
            if (useCodeSnippet) {
                const shouldCompleteFunction = isValidFunctionCompletionContext(languageService, fileName, offset, document);
                if (shouldCompleteFunction) {
                    const { snippet, parameterCount } = (0, snippetForFunctionCall_1.snippetForFunctionCall)(item, details.displayParts);
                    if (item.textEdit) {
                        item.textEdit.newText = snippet;
                    }
                    if (item.insertText) {
                        item.insertText = snippet;
                    }
                    item.insertTextFormat = vscode.InsertTextFormat.Snippet;
                    if (parameterCount > 0) {
                        //Fix for https://github.com/microsoft/vscode/issues/104059
                        //Don't show parameter hints if "editor.parameterHints.enabled": false
                        // if (await getConfiguration('editor.parameterHints.enabled', document.uri)) {
                        // 	item.command = {
                        // 		title: 'triggerParameterHints',
                        // 		command: 'editor.action.triggerParameterHints',
                        // 	};
                        // }
                    }
                }
            }
        }
        return item;
        function toResource(path) {
            return shared.getUriByPath(path);
        }
    });
}
exports.register = register;
function isValidFunctionCompletionContext(client, filepath, offset, document) {
    // Workaround for https://github.com/microsoft/TypeScript/issues/12677
    // Don't complete function calls inside of destructive assignments or imports
    try {
        const response = client.getQuickInfoAtPosition(filepath, offset);
        if (response) {
            switch (response.kind) {
                case 'var':
                case 'let':
                case 'const':
                case 'alias':
                    return false;
            }
        }
    }
    catch (_a) {
        // Noop
    }
    // Don't complete function call if there is already something that looks like a function call
    // https://github.com/microsoft/vscode/issues/18131
    const position = document.positionAt(offset);
    const after = getLineText(document, position.line).slice(position.character);
    return after.match(/^[a-z_$0-9]*\s*\(/gi) === null;
}
function getLineText(document, line) {
    const endOffset = document.offsetAt({ line: line + 1, character: 0 });
    const end = document.positionAt(endOffset);
    const text = document.getText({
        start: { line: line, character: 0 },
        end: end.line === line ? end : document.positionAt(endOffset - 1),
    });
    return text;
}
exports.getLineText = getLineText;
//# sourceMappingURL=resolve.js.map
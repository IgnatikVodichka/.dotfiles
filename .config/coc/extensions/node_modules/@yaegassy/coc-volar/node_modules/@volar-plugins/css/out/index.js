var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const css = require("vscode-css-languageservice");
const vscode = require("vscode-languageserver-protocol");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const path = require("path");
function default_1() {
    const stylesheets = new WeakMap();
    let inited = false;
    let context;
    let cssLs;
    let scssLs;
    let lessLs;
    let postcssLs;
    return {
        setup(_context) {
            context = _context;
            cssLs = css.getCSSLanguageService({ fileSystemProvider: _context.env.fileSystemProvider });
            scssLs = css.getSCSSLanguageService({ fileSystemProvider: _context.env.fileSystemProvider });
            lessLs = css.getLESSLanguageService({ fileSystemProvider: _context.env.fileSystemProvider });
            postcssLs = Object.assign(Object.assign({}, scssLs), { doValidation: (document, stylesheet, documentSettings) => {
                    let errors = scssLs.doValidation(document, stylesheet, documentSettings);
                    errors = errors.filter(error => error.code !== 'css-semicolonexpected');
                    errors = errors.filter(error => error.code !== 'css-ruleorselectorexpected');
                    errors = errors.filter(error => error.code !== 'unknownAtRules');
                    return errors;
                } });
        },
        complete: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/css-language-features/server/src/cssServer.ts#L97
            triggerCharacters: ['/', '-', ':'],
            on(document, position) {
                return __awaiter(this, void 0, void 0, function* () {
                    return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        if (!context.env.documentContext)
                            return;
                        const settings = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId));
                        const cssResult = yield cssLs.doComplete2(document, position, stylesheet, context.env.documentContext, settings === null || settings === void 0 ? void 0 : settings.completion);
                        return cssResult;
                    }));
                });
            },
        },
        rename: {
            prepare(document, position) {
                return worker(document, (stylesheet, cssLs) => {
                    return cssLs.prepareRename(document, position, stylesheet);
                });
            },
            on(document, position, newName) {
                return worker(document, (stylesheet, cssLs) => {
                    return cssLs.doRename(document, position, newName, stylesheet);
                });
            },
        },
        codeAction: {
            on(document, range, context) {
                return worker(document, (stylesheet, cssLs) => {
                    return cssLs.doCodeActions2(document, range, context, stylesheet);
                });
            },
        },
        definition: {
            on(document, position) {
                return worker(document, (stylesheet, cssLs) => {
                    const location = cssLs.findDefinition(document, position, stylesheet);
                    if (location) {
                        return [vscode.LocationLink.create(location.uri, location.range, location.range)];
                    }
                });
            },
        },
        validation: {
            onSyntactic(document) {
                return __awaiter(this, void 0, void 0, function* () {
                    return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const settings = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId));
                        return cssLs.doValidation(document, stylesheet, settings);
                    }));
                });
            },
        },
        doHover(document, position) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const settings = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId));
                    return cssLs.doHover(document, position, stylesheet, settings === null || settings === void 0 ? void 0 : settings.hover);
                }));
            });
        },
        findReferences(document, position) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findReferences(document, position, stylesheet);
            });
        },
        findDocumentHighlights(document, position) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentHighlights(document, position, stylesheet);
            });
        },
        findDocumentLinks(document) {
            return worker(document, (stylesheet, cssLs) => {
                if (!context.env.documentContext)
                    return;
                return cssLs.findDocumentLinks(document, stylesheet, context.env.documentContext);
            });
        },
        findDocumentSymbols(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentSymbols(document, stylesheet);
            });
        },
        findDocumentColors(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.findDocumentColors(document, stylesheet);
            });
        },
        getColorPresentations(document, color, range) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getColorPresentations(document, stylesheet, color, range);
            });
        },
        getFoldingRanges(document) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getFoldingRanges(document, stylesheet);
            });
        },
        getSelectionRanges(document, positions) {
            return worker(document, (stylesheet, cssLs) => {
                return cssLs.getSelectionRanges(document, positions, stylesheet);
            });
        },
        format(document, range, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (_stylesheet, cssLs) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const options_2 = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration(document.languageId + '.format'));
                    if ((options_2 === null || options_2 === void 0 ? void 0 : options_2.enable) === false) {
                        return;
                    }
                    const edits = cssLs.format(document, range, Object.assign(Object.assign({}, options_2), options));
                    const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
                    return [{
                            newText: '\n' + newText.trim() + '\n',
                            range: {
                                start: document.positionAt(0),
                                end: document.positionAt(document.getText().length),
                            },
                        }];
                }));
            });
        },
    };
    function initCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!inited) {
                (_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.onDidChangeConfiguration(() => __awaiter(this, void 0, void 0, function* () {
                    const customData = yield getCustomData();
                    cssLs.setDataProviders(true, customData);
                    scssLs.setDataProviders(true, customData);
                    lessLs.setDataProviders(true, customData);
                }));
                const customData = yield getCustomData();
                cssLs.setDataProviders(true, customData);
                scssLs.setDataProviders(true, customData);
                lessLs.setDataProviders(true, customData);
                inited = true;
            }
        });
    }
    function getCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const configHost = context.env.configurationHost;
            if (configHost) {
                const customData = (_a = yield configHost.getConfiguration('css.customData')) !== null && _a !== void 0 ? _a : [];
                const newData = [];
                for (const customDataPath of customData) {
                    try {
                        const jsonPath = path.resolve(customDataPath);
                        newData.push(css.newCSSDataProvider(require(jsonPath)));
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                return newData;
            }
            return [];
        });
    }
    function getCssLs(lang) {
        switch (lang) {
            case 'css': return cssLs;
            case 'scss': return scssLs;
            case 'less': return lessLs;
            case 'postcss': return postcssLs;
        }
    }
    function getStylesheet(document) {
        const cache = stylesheets.get(document);
        if (cache) {
            const [cacheVersion, cacheStylesheet] = cache;
            if (cacheVersion === document.version) {
                return cacheStylesheet;
            }
        }
        const cssLs = getCssLs(document.languageId);
        if (!cssLs)
            return;
        const stylesheet = cssLs.parseStylesheet(document);
        stylesheets.set(document, [document.version, stylesheet]);
        return stylesheet;
    }
    function worker(document, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const stylesheet = getStylesheet(document);
            if (!stylesheet)
                return;
            const cssLs = getCssLs(document.languageId);
            if (!cssLs)
                return;
            yield initCustomData();
            return callback(stylesheet, cssLs);
        });
    }
}
exports.default = default_1;
;
//# sourceMappingURL=index.js.map
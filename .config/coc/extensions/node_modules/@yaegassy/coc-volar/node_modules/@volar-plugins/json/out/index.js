var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const json = require("vscode-json-languageservice");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
function default_1(settings) {
    const jsonDocuments = new WeakMap();
    let context;
    let jsonLs;
    return {
        setup(_context) {
            context = _context;
            jsonLs = json.getLanguageService({ schemaRequestService: _context.env.schemaRequestService });
            if (settings) {
                jsonLs.configure(settings);
            }
        },
        complete: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/json-language-features/server/src/jsonServer.ts#L150
            triggerCharacters: ['"', ':'],
            on(document, position) {
                return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                    return yield jsonLs.doComplete(document, position, jsonDocument);
                }));
            },
            resolve(item) {
                return __awaiter(this, void 0, void 0, function* () {
                    return yield jsonLs.doResolve(item);
                });
            },
        },
        definition: {
            on(document, position) {
                return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                    return yield jsonLs.findDefinition(document, position, jsonDocument);
                }));
            },
        },
        validation: {
            onSyntactic(document) {
                return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                    const documentLanguageSettings = undefined; // await getSettings(); // TODO
                    return yield jsonLs.doValidation(document, jsonDocument, documentLanguageSettings, undefined);
                }));
            },
        },
        doHover(document, position) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.doHover(document, position, jsonDocument);
            }));
        },
        findDocumentLinks(document) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.findLinks(document, jsonDocument);
            }));
        },
        findDocumentSymbols(document) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.findDocumentSymbols(document, jsonDocument);
            }));
        },
        findDocumentColors(document) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.findDocumentColors(document, jsonDocument);
            }));
        },
        getColorPresentations(document, color, range) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.getColorPresentations(document, jsonDocument, color, range);
            }));
        },
        getFoldingRanges(document) {
            return worker(document, () => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.getFoldingRanges(document);
            }));
        },
        getSelectionRanges(document, positions) {
            return worker(document, (jsonDocument) => __awaiter(this, void 0, void 0, function* () {
                return yield jsonLs.getSelectionRanges(document, positions, jsonDocument);
            }));
        },
        format(document, range, options) {
            return worker(document, () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const options_2 = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('json.format'));
                if ((options_2 === null || options_2 === void 0 ? void 0 : options_2.enable) === false) {
                    return;
                }
                const edits = jsonLs.format(document, range, Object.assign(Object.assign(Object.assign({}, options_2), options), { insertFinalNewline: true }));
                if (!edits.length) {
                    return edits;
                }
                const newText = vscode_languageserver_textdocument_1.TextDocument.applyEdits(document, edits);
                return [{
                        newText: '\n' + newText.trim() + '\n',
                        range: {
                            start: document.positionAt(0),
                            end: document.positionAt(document.getText().length),
                        },
                    }];
            }));
        },
    };
    function worker(document, callback) {
        const jsonDocument = getJsonDocument(document);
        if (!jsonDocument)
            return;
        return callback(jsonDocument);
    }
    function getJsonDocument(textDocument) {
        if (textDocument.languageId !== 'json' && textDocument.languageId !== 'jsonc')
            return;
        const cache = jsonDocuments.get(textDocument);
        if (cache) {
            const [cacheVersion, cacheDoc] = cache;
            if (cacheVersion === textDocument.version) {
                return cacheDoc;
            }
        }
        const doc = jsonLs.parseJSONDocument(textDocument);
        jsonDocuments.set(textDocument, [textDocument.version, doc]);
        return doc;
    }
}
exports.default = default_1;
//# sourceMappingURL=index.js.map